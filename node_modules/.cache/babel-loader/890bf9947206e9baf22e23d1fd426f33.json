{"ast":null,"code":"var _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar Joi = require('joi');\nvar crypto = require('crypto');\nvar _require = require('./hooks/getLoginState'),\n  getLoginState = _require.defaultState;\nvar isHttps = /^https:/i;\nvar defaultSessionIdGenerator = function defaultSessionIdGenerator() {\n  return crypto.randomBytes(16).toString('hex');\n};\nvar paramsSchema = Joi.object({\n  secret: Joi.alternatives([Joi.string().min(8), Joi.binary().min(8), Joi.array().items(Joi.string().min(8), Joi.binary().min(8))]).required(),\n  session: Joi.object({\n    rolling: Joi.boolean().optional().default(true),\n    rollingDuration: Joi.when(Joi.ref('rolling'), {\n      is: true,\n      then: Joi.number().integer().messages({\n        'number.base': '\"session.rollingDuration\" must be provided an integer value when \"session.rolling\" is true'\n      }),\n      otherwise: Joi.boolean().valid(false).messages({\n        'any.only': '\"session.rollingDuration\" must be false when \"session.rolling\" is disabled'\n      })\n    }).optional().default(function (parent) {\n      return parent.rolling ? 24 * 60 * 60 : false;\n    }),\n    // 1 day when rolling is enabled, else false\n    absoluteDuration: Joi.when(Joi.ref('rolling'), {\n      is: false,\n      then: Joi.number().integer().messages({\n        'number.base': '\"session.absoluteDuration\" must be provided an integer value when \"session.rolling\" is false'\n      }),\n      otherwise: Joi.alternatives([Joi.number().integer(), Joi.boolean().valid(false)])\n    }).optional().default(7 * 24 * 60 * 60),\n    // 7 days,\n    name: Joi.string().pattern(/^[0-9a-zA-Z_.-]+$/, {\n      name: 'cookie name'\n    }).optional().default('appSession'),\n    store: Joi.object().optional().when(Joi.ref('/backchannelLogout'), {\n      not: false,\n      then: Joi.when('/backchannelLogout.store', {\n        not: Joi.exist(),\n        then: Joi.when('/backchannelLogout.isLoggedOut', {\n          not: Joi.exist(),\n          then: Joi.object().required().messages({\n            'any.required': \"Back-Channel Logout requires a \\\"backchannelLogout.store\\\" (you can also reuse \\\"session.store\\\" if you have stateful sessions) or custom hooks for \\\"isLoggedOut\\\" and \\\"onLogoutToken\\\".\"\n          })\n        })\n      })\n    }),\n    genid: Joi.function().maxArity(1).optional().default(function () {\n      return defaultSessionIdGenerator;\n    }),\n    signSessionStoreCookie: Joi.boolean().optional().default(false),\n    requireSignedSessionStoreCookie: Joi.boolean().optional().default(Joi.ref('signSessionStoreCookie')),\n    cookie: Joi.object({\n      domain: Joi.string().optional(),\n      transient: Joi.boolean().optional().default(false),\n      httpOnly: Joi.boolean().optional().default(true),\n      sameSite: Joi.string().valid('Lax', 'Strict', 'None').optional().default('Lax'),\n      secure: Joi.when(Joi.ref('/baseURL'), {\n        is: Joi.string().pattern(isHttps),\n        then: Joi.boolean().default(true).custom(function (value, _ref) {\n          var warn = _ref.warn;\n          if (!value) warn('insecure.cookie');\n          return value;\n        }).messages({\n          'insecure.cookie': \"Setting your cookie to insecure when over https is not recommended, I hope you know what you're doing.\"\n        }),\n        otherwise: Joi.boolean().valid(false).default(false).messages({\n          'any.only': 'Cookies set with the `Secure` property wont be attached to http requests'\n        })\n      }),\n      path: Joi.string().uri({\n        relativeOnly: true\n      }).optional()\n    }).default().unknown(false)\n  }).default().unknown(false),\n  transactionCookie: Joi.object({\n    sameSite: Joi.string().valid('Lax', 'Strict', 'None').optional().default(Joi.ref('...session.cookie.sameSite')),\n    name: Joi.string().optional().default('auth_verification')\n  }).default().unknown(false),\n  auth0Logout: Joi.boolean().optional(),\n  tokenEndpointParams: Joi.object().optional(),\n  authorizationParams: Joi.object({\n    response_type: Joi.string().optional().valid('id_token', 'code id_token', 'code').default('id_token'),\n    scope: Joi.string().optional().pattern(/\\bopenid\\b/, 'contains openid').default('openid profile email'),\n    response_mode: Joi.string().optional().when('response_type', {\n      is: 'code',\n      then: Joi.valid('query', 'form_post'),\n      otherwise: Joi.valid('form_post').default('form_post')\n    })\n  }).optional().unknown(true).default(),\n  logoutParams: Joi.object().optional(),\n  backchannelLogout: Joi.alternatives([Joi.object({\n    store: Joi.object().optional(),\n    onLogin: Joi.alternatives([Joi.function(), Joi.boolean().valid(false)]).optional(),\n    isLoggedOut: Joi.alternatives([Joi.function(), Joi.boolean().valid(false)]).optional(),\n    onLogoutToken: Joi.function().optional()\n  }), Joi.boolean()]).default(false),\n  baseURL: Joi.string().uri().required().when(Joi.ref('authorizationParams.response_mode'), {\n    is: 'form_post',\n    then: Joi.string().pattern(isHttps).rule({\n      warn: true,\n      message: \"Using 'form_post' for response_mode may cause issues for you logging in over http, see https://github.com/auth0/express-openid-connect/blob/master/FAQ.md\"\n    })\n  }),\n  clientID: Joi.string().required(),\n  clientSecret: Joi.string().when(Joi.ref('clientAuthMethod', {\n    adjust: function adjust(value) {\n      return value && value.includes('client_secret');\n    }\n  }), {\n    is: true,\n    then: Joi.string().required().messages({\n      'any.required': \"\\\"clientSecret\\\" is required for the \\\"clientAuthMethod\\\" \\\"{{clientAuthMethod}}\\\"\"\n    })\n  }).when(Joi.ref('idTokenSigningAlg', {\n    adjust: function adjust(value) {\n      return value && value.startsWith('HS');\n    }\n  }), {\n    is: true,\n    then: Joi.string().required().messages({\n      'any.required': '\"clientSecret\" is required for ID tokens with HMAC based algorithms'\n    })\n  }),\n  clockTolerance: Joi.number().optional().default(60),\n  enableTelemetry: Joi.boolean().optional().default(true),\n  errorOnRequiredAuth: Joi.boolean().optional().default(false),\n  attemptSilentLogin: Joi.boolean().optional().default(false),\n  getLoginState: Joi.function().optional().default(function () {\n    return getLoginState;\n  }),\n  afterCallback: Joi.function().optional(),\n  identityClaimFilter: Joi.array().optional().default(['aud', 'iss', 'iat', 'exp', 'nbf', 'nonce', 'azp', 'auth_time', 's_hash', 'at_hash', 'c_hash']),\n  idpLogout: Joi.boolean().optional().default(function (parent) {\n    return parent.auth0Logout || false;\n  }),\n  idTokenSigningAlg: Joi.string().insensitive().not('none').optional().default('RS256'),\n  issuerBaseURL: Joi.string().uri().required(),\n  legacySameSiteCookie: Joi.boolean().optional().default(true),\n  authRequired: Joi.boolean().optional().default(true),\n  pushedAuthorizationRequests: Joi.boolean().optional().default(false),\n  routes: Joi.object({\n    login: Joi.alternatives([Joi.string().uri({\n      relativeOnly: true\n    }), Joi.boolean().valid(false)]).default('/login'),\n    logout: Joi.alternatives([Joi.string().uri({\n      relativeOnly: true\n    }), Joi.boolean().valid(false)]).default('/logout'),\n    callback: Joi.alternatives([Joi.string().uri({\n      relativeOnly: true\n    }), Joi.boolean().valid(false)]).default('/callback'),\n    postLogoutRedirect: Joi.string().uri({\n      allowRelative: true\n    }).default(''),\n    backchannelLogout: Joi.string().uri({\n      allowRelative: true\n    }).default('/backchannel-logout')\n  }).default().unknown(false),\n  clientAuthMethod: Joi.string().valid('client_secret_basic', 'client_secret_post', 'client_secret_jwt', 'private_key_jwt', 'none').optional().default(function (parent) {\n    if (parent.authorizationParams.response_type === 'id_token' && !parent.pushedAuthorizationRequests) {\n      return 'none';\n    }\n    if (parent.clientAssertionSigningKey) {\n      return 'private_key_jwt';\n    }\n    return 'client_secret_basic';\n  }).when(Joi.ref('authorizationParams.response_type', {\n    adjust: function adjust(value) {\n      return value && value.includes('code');\n    }\n  }), {\n    is: true,\n    then: Joi.string().invalid('none').messages({\n      'any.only': 'Public code flow clients are not supported.'\n    })\n  }).when(Joi.ref('pushedAuthorizationRequests'), {\n    is: true,\n    then: Joi.string().invalid('none').messages({\n      'any.only': 'Public PAR clients are not supported.'\n    })\n  }),\n  clientAssertionSigningKey: Joi.any().optional().when(Joi.ref('clientAuthMethod'), {\n    is: 'private_key_jwt',\n    then: Joi.any().required().messages({\n      'any.required': '\"clientAssertionSigningKey\" is required for a \"clientAuthMethod\" of \"private_key_jwt\"'\n    })\n  }),\n  // <Object> | <string> | <Buffer> | <KeyObject>,\n  clientAssertionSigningAlg: Joi.string().valid('RS256', 'RS384', 'RS512', 'PS256', 'PS384', 'PS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA').optional(),\n  discoveryCacheMaxAge: Joi.number().optional().min(0).default(10 * 60 * 1000),\n  httpTimeout: Joi.number().optional().min(500).default(5000),\n  httpUserAgent: Joi.string().optional(),\n  httpAgent: Joi.object().optional()\n});\nmodule.exports.get = function () {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = _objectSpread({\n    secret: process.env.SECRET,\n    issuerBaseURL: process.env.ISSUER_BASE_URL,\n    baseURL: process.env.BASE_URL,\n    clientID: process.env.CLIENT_ID,\n    clientSecret: process.env.CLIENT_SECRET\n  }, config);\n  var _paramsSchema$validat = paramsSchema.validate(config),\n    value = _paramsSchema$validat.value,\n    error = _paramsSchema$validat.error,\n    warning = _paramsSchema$validat.warning;\n  if (error) {\n    throw new TypeError(error.details[0].message);\n  }\n  if (warning) {\n    console.warn(warning.message);\n  }\n  return value;\n};","map":null,"metadata":{},"sourceType":"script"}