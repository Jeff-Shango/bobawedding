{"ast":null,"code":"var _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _require = require('../help/key_object'),\n  createPublicKey = _require.createPublicKey,\n  createPrivateKey = _require.createPrivateKey,\n  createSecretKey = _require.createSecretKey,\n  KeyObject = _require.KeyObject;\nvar base64url = require('../help/base64url');\nvar isObject = require('../help/is_object');\nvar _require2 = require('../help/key_utils'),\n  jwkToPem = _require2.jwkToPem;\nvar errors = require('../errors');\nvar RSAKey = require('./key/rsa');\nvar ECKey = require('./key/ec');\nvar OKPKey = require('./key/okp');\nvar OctKey = require('./key/oct');\nvar importable = new Set(['string', 'buffer', 'object']);\nvar mergedParameters = function mergedParameters() {\n  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256']\n  }, target);\n};\nvar openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/;\nvar asKey = function asKey(key, parameters) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$calculateMissing = _ref.calculateMissingRSAPrimes,\n    calculateMissingRSAPrimes = _ref$calculateMissing === void 0 ? false : _ref$calculateMissing;\n  var privateKey, publicKey, secret;\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object');\n  }\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided');\n  }\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key;\n        break;\n      case 'public':\n        publicKey = key;\n        break;\n      case 'secret':\n        secret = key;\n        break;\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') {\n    // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k));\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = {\n          type: 'secret'\n        };\n      }\n    }\n    parameters = mergedParameters(parameters, key);\n  } else if (typeof key === 'object' && key && 'kty' in key) {\n    // assume JWK formatted asymmetric key <Object>\n    var _ref2 = parameters || {\n      calculateMissingRSAPrimes: calculateMissingRSAPrimes\n    };\n    var _ref2$calculateMissin = _ref2.calculateMissingRSAPrimes;\n    calculateMissingRSAPrimes = _ref2$calculateMissin === void 0 ? false : _ref2$calculateMissin;\n    var pem;\n    try {\n      pem = jwkToPem(key, {\n        calculateMissingRSAPrimes: calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem);\n    } else if (pem) {\n      publicKey = createPublicKey(pem);\n    }\n    parameters = mergedParameters({}, key);\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) {\n    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key);\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    try {\n      publicKey = createPublicKey(key);\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        });\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key));\n      }\n    } catch (err) {}\n  }\n  var keyObject = privateKey || publicKey || secret;\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters);\n      case 'ec':\n        return new ECKey(keyObject, parameters);\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters);\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported');\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters);\n  }\n  throw new errors.JWKImportFailed('key import failed');\n};\nmodule.exports = asKey;","map":null,"metadata":{},"sourceType":"script"}