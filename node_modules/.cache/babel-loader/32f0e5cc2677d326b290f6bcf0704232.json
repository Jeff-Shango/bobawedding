{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _setPrototypeOf = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/setPrototypeOf\");\nvar _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _createClass = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _get = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _possibleConstructorReturn = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nvar _wrapNativeSuper = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\nvar _asyncToGenerator = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nfunction _wrapRegExp() { _wrapRegExp = function _wrapRegExp(e, r) { return new BabelRegExp(e, void 0, r); }; var e = RegExp.prototype, r = new WeakMap(); function BabelRegExp(e, t, p) { var o = new RegExp(e, t); return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype); } function buildGroups(e, t) { var p = r.get(t); return Object.keys(p).reduce(function (r, t) { var o = p[t]; if (\"number\" == typeof o) r[t] = e[o];else { for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) i++; r[t] = e[o[i]]; } return r; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) { var t = e.exec.call(this, r); if (t) { t.groups = buildGroups(t, this); var p = t.indices; p && (p.groups = buildGroups(p, this)); } return t; }, BabelRegExp.prototype[Symbol.replace] = function (t, p) { if (\"string\" == typeof p) { var o = r.get(this); return e[Symbol.replace].call(this, t, p.replace(/\\$<([^>]+)>/g, function (e, r) { var t = o[r]; return \"$\" + (Array.isArray(t) ? t.join(\"$\") : t); })); } if (\"function\" == typeof p) { var i = this; return e[Symbol.replace].call(this, t, function () { var e = arguments; return \"object\" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e); }); } return e[Symbol.replace].call(this, t, p); }, _wrapRegExp.apply(this, arguments); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;\nvar util_1 = require(\"util\");\nvar stream_1 = require(\"stream\");\nvar fs_1 = require(\"fs\");\nvar url_1 = require(\"url\");\nvar http = require(\"http\");\nvar http_1 = require(\"http\");\nvar https = require(\"https\");\nvar http_timer_1 = require(\"@szmarczak/http-timer\");\nvar cacheable_lookup_1 = require(\"cacheable-lookup\");\nvar CacheableRequest = require(\"cacheable-request\");\nvar decompressResponse = require(\"decompress-response\");\n// @ts-expect-error Missing types\nvar http2wrapper = require(\"http2-wrapper\");\nvar lowercaseKeys = require(\"lowercase-keys\");\nvar is_1 = require(\"@sindresorhus/is\");\nvar get_body_size_1 = require(\"./utils/get-body-size\");\nvar is_form_data_1 = require(\"./utils/is-form-data\");\nvar proxy_events_1 = require(\"./utils/proxy-events\");\nvar timed_out_1 = require(\"./utils/timed-out\");\nvar url_to_options_1 = require(\"./utils/url-to-options\");\nvar options_to_url_1 = require(\"./utils/options-to-url\");\nvar weakable_map_1 = require(\"./utils/weakable-map\");\nvar get_buffer_1 = require(\"./utils/get-buffer\");\nvar dns_ip_version_1 = require(\"./utils/dns-ip-version\");\nvar is_response_ok_1 = require(\"./utils/is-response-ok\");\nvar deprecation_warning_1 = require(\"../utils/deprecation-warning\");\nvar normalize_arguments_1 = require(\"../as-promise/normalize-arguments\");\nvar calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\nvar globalDnsCache;\nvar kRequest = Symbol('request');\nvar kResponse = Symbol('response');\nvar kResponseSize = Symbol('responseSize');\nvar kDownloadedSize = Symbol('downloadedSize');\nvar kBodySize = Symbol('bodySize');\nvar kUploadedSize = Symbol('uploadedSize');\nvar kServerResponsesPiped = Symbol('serverResponsesPiped');\nvar kUnproxyEvents = Symbol('unproxyEvents');\nvar kIsFromCache = Symbol('isFromCache');\nvar kCancelTimeouts = Symbol('cancelTimeouts');\nvar kStartedReading = Symbol('startedReading');\nvar kStopReading = Symbol('stopReading');\nvar kTriggerRead = Symbol('triggerRead');\nvar kBody = Symbol('body');\nvar kJobs = Symbol('jobs');\nvar kOriginalResponse = Symbol('originalResponse');\nvar kRetryTimeout = Symbol('retryTimeout');\nexports.kIsNormalizedAlready = Symbol('isNormalizedAlready');\nvar supportsBrotli = is_1.default.string(process.versions.brotli);\nexports.withoutBody = new Set(['GET', 'HEAD']);\nexports.knownHookEvents = ['init', 'beforeRequest', 'beforeRedirect', 'beforeError', 'beforeRetry',\n// Promise-Only\n'afterResponse'];\nfunction validateSearchParameters(searchParameters) {\n  // eslint-disable-next-line guard-for-in\n  for (var key in searchParameters) {\n    var value = searchParameters[key];\n    if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {\n      throw new TypeError(\"The `searchParams` value '\".concat(String(value), \"' must be a string, number, boolean or null\"));\n    }\n  }\n}\nfunction isClientRequest(clientRequest) {\n  return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);\n}\nvar cacheableStore = new weakable_map_1.default();\nvar waitForOpenFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n            var onError = function onError(error) {\n              reject(error);\n            };\n            // Node.js 12 has incomplete types\n            if (!file.pending) {\n              resolve();\n            }\n            file.once('error', onError);\n            file.once('ready', function () {\n              file.off('error', onError);\n              resolve();\n            });\n          }));\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function waitForOpenFile(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nvar nonEnumerableProperties = ['context', 'body', 'json', 'form'];\nexports.setNonEnumerableProperties = function (sources, to) {\n  // Non enumerable properties shall not be merged\n  var properties = {};\n  var _iterator = _createForOfIteratorHelper(sources),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var source = _step.value;\n      if (!source) {\n        continue;\n      }\n      for (var _i = 0, _nonEnumerablePropert = nonEnumerableProperties; _i < _nonEnumerablePropert.length; _i++) {\n        var name = _nonEnumerablePropert[_i];\n        if (!(name in source)) {\n          continue;\n        }\n        properties[name] = {\n          writable: true,\n          configurable: true,\n          enumerable: false,\n          // @ts-expect-error TS doesn't see the check above\n          value: source[name]\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  Object.defineProperties(to, properties);\n};\n/**\nAn error to be thrown when a request fails.\nContains a `code` property with error class code, like `ECONNREFUSED`.\n*/\nvar RequestError = /*#__PURE__*/function (_Error) {\n  _inherits(RequestError, _Error);\n  function RequestError(message, error, self) {\n    var _this;\n    _classCallCheck(this, RequestError);\n    var _a, _b;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RequestError).call(this, message));\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    _this.name = 'RequestError';\n    _this.code = (_a = error.code) !== null && _a !== void 0 ? _a : 'ERR_GOT_REQUEST_ERROR';\n    if (self instanceof Request) {\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'request', {\n        enumerable: false,\n        value: self\n      });\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'response', {\n        enumerable: false,\n        value: self[kResponse]\n      });\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'options', {\n        // This fails because of TS 3.7.2 useDefineForClassFields\n        // Ref: https://github.com/microsoft/TypeScript/issues/34972\n        enumerable: false,\n        value: self.options\n      });\n    } else {\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'options', {\n        // This fails because of TS 3.7.2 useDefineForClassFields\n        // Ref: https://github.com/microsoft/TypeScript/issues/34972\n        enumerable: false,\n        value: self\n      });\n    }\n    _this.timings = (_b = _this.request) === null || _b === void 0 ? void 0 : _b.timings;\n    // Recover the original stacktrace\n    if (is_1.default.string(error.stack) && is_1.default.string(_this.stack)) {\n      var indexOfMessage = _this.stack.indexOf(_this.message) + _this.message.length;\n      var thisStackTrace = _this.stack.slice(indexOfMessage).split('\\n').reverse();\n      var errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\\n').reverse();\n      // Remove duplicated traces\n      while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {\n        thisStackTrace.shift();\n      }\n      _this.stack = \"\".concat(_this.stack.slice(0, indexOfMessage)).concat(thisStackTrace.reverse().join('\\n')).concat(errorStackTrace.reverse().join('\\n'));\n    }\n    return _this;\n  }\n  return RequestError;\n}(_wrapNativeSuper(Error));\nexports.RequestError = RequestError;\n/**\nAn error to be thrown when the server redirects you more than ten times.\nIncludes a `response` property.\n*/\nvar MaxRedirectsError = /*#__PURE__*/function (_RequestError) {\n  _inherits(MaxRedirectsError, _RequestError);\n  function MaxRedirectsError(request) {\n    var _this2;\n    _classCallCheck(this, MaxRedirectsError);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MaxRedirectsError).call(this, \"Redirected \".concat(request.options.maxRedirects, \" times. Aborting.\"), {}, request));\n    _this2.name = 'MaxRedirectsError';\n    _this2.code = 'ERR_TOO_MANY_REDIRECTS';\n    return _this2;\n  }\n  return MaxRedirectsError;\n}(RequestError);\nexports.MaxRedirectsError = MaxRedirectsError;\n/**\nAn error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.\nIncludes a `response` property.\n*/\nvar HTTPError = /*#__PURE__*/function (_RequestError2) {\n  _inherits(HTTPError, _RequestError2);\n  function HTTPError(response) {\n    var _this3;\n    _classCallCheck(this, HTTPError);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(HTTPError).call(this, \"Response code \".concat(response.statusCode, \" (\").concat(response.statusMessage, \")\"), {}, response.request));\n    _this3.name = 'HTTPError';\n    _this3.code = 'ERR_NON_2XX_3XX_RESPONSE';\n    return _this3;\n  }\n  return HTTPError;\n}(RequestError);\nexports.HTTPError = HTTPError;\n/**\nAn error to be thrown when a cache method fails.\nFor example, if the database goes down or there's a filesystem error.\n*/\nvar CacheError = /*#__PURE__*/function (_RequestError3) {\n  _inherits(CacheError, _RequestError3);\n  function CacheError(error, request) {\n    var _this4;\n    _classCallCheck(this, CacheError);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(CacheError).call(this, error.message, error, request));\n    _this4.name = 'CacheError';\n    _this4.code = _this4.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : _this4.code;\n    return _this4;\n  }\n  return CacheError;\n}(RequestError);\nexports.CacheError = CacheError;\n/**\nAn error to be thrown when the request body is a stream and an error occurs while reading from that stream.\n*/\nvar UploadError = /*#__PURE__*/function (_RequestError4) {\n  _inherits(UploadError, _RequestError4);\n  function UploadError(error, request) {\n    var _this5;\n    _classCallCheck(this, UploadError);\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(UploadError).call(this, error.message, error, request));\n    _this5.name = 'UploadError';\n    _this5.code = _this5.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : _this5.code;\n    return _this5;\n  }\n  return UploadError;\n}(RequestError);\nexports.UploadError = UploadError;\n/**\nAn error to be thrown when the request is aborted due to a timeout.\nIncludes an `event` and `timings` property.\n*/\nvar TimeoutError = /*#__PURE__*/function (_RequestError5) {\n  _inherits(TimeoutError, _RequestError5);\n  function TimeoutError(error, timings, request) {\n    var _this6;\n    _classCallCheck(this, TimeoutError);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(TimeoutError).call(this, error.message, error, request));\n    _this6.name = 'TimeoutError';\n    _this6.event = error.event;\n    _this6.timings = timings;\n    return _this6;\n  }\n  return TimeoutError;\n}(RequestError);\nexports.TimeoutError = TimeoutError;\n/**\nAn error to be thrown when reading from response stream fails.\n*/\nvar ReadError = /*#__PURE__*/function (_RequestError6) {\n  _inherits(ReadError, _RequestError6);\n  function ReadError(error, request) {\n    var _this7;\n    _classCallCheck(this, ReadError);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(ReadError).call(this, error.message, error, request));\n    _this7.name = 'ReadError';\n    _this7.code = _this7.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : _this7.code;\n    return _this7;\n  }\n  return ReadError;\n}(RequestError);\nexports.ReadError = ReadError;\n/**\nAn error to be thrown when given an unsupported protocol.\n*/\nvar UnsupportedProtocolError = /*#__PURE__*/function (_RequestError7) {\n  _inherits(UnsupportedProtocolError, _RequestError7);\n  function UnsupportedProtocolError(options) {\n    var _this8;\n    _classCallCheck(this, UnsupportedProtocolError);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedProtocolError).call(this, \"Unsupported protocol \\\"\".concat(options.url.protocol, \"\\\"\"), {}, options));\n    _this8.name = 'UnsupportedProtocolError';\n    _this8.code = 'ERR_UNSUPPORTED_PROTOCOL';\n    return _this8;\n  }\n  return UnsupportedProtocolError;\n}(RequestError);\nexports.UnsupportedProtocolError = UnsupportedProtocolError;\nvar proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade', 'timeout'];\nvar Request = /*#__PURE__*/function (_stream_1$Duplex) {\n  _inherits(Request, _stream_1$Duplex);\n  function Request(url) {\n    var _this9;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var defaults = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, Request);\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(Request).call(this, {\n      // This must be false, to enable throwing after destroy\n      // It is used for retry logic in Promise API\n      autoDestroy: false,\n      // It needs to be zero because we're just proxying the data to another stream\n      highWaterMark: 0\n    }));\n    _this9[kDownloadedSize] = 0;\n    _this9[kUploadedSize] = 0;\n    _this9.requestInitialized = false;\n    _this9[kServerResponsesPiped] = new Set();\n    _this9.redirects = [];\n    _this9[kStopReading] = false;\n    _this9[kTriggerRead] = false;\n    _this9[kJobs] = [];\n    _this9.retryCount = 0;\n    // TODO: Remove this when targeting Node.js >= 12\n    _this9._progressCallbacks = [];\n    var unlockWrite = function unlockWrite() {\n      return _this9._unlockWrite();\n    };\n    var lockWrite = function lockWrite() {\n      return _this9._lockWrite();\n    };\n    _this9.on('pipe', function (source) {\n      source.prependListener('data', unlockWrite);\n      source.on('data', lockWrite);\n      source.prependListener('end', unlockWrite);\n      source.on('end', lockWrite);\n    });\n    _this9.on('unpipe', function (source) {\n      source.off('data', unlockWrite);\n      source.off('data', lockWrite);\n      source.off('end', unlockWrite);\n      source.off('end', lockWrite);\n    });\n    _this9.on('pipe', function (source) {\n      if (source instanceof http_1.IncomingMessage) {\n        _this9.options.headers = _objectSpread({}, source.headers, _this9.options.headers);\n      }\n    });\n    var json = options.json,\n      body = options.body,\n      form = options.form;\n    if (json || body || form) {\n      _this9._lockWrite();\n    }\n    if (exports.kIsNormalizedAlready in options) {\n      _this9.options = options;\n    } else {\n      try {\n        // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible\n        _this9.options = _this9.constructor.normalizeArguments(url, options, defaults);\n      } catch (error) {\n        // TODO: Move this to `_destroy()`\n        if (is_1.default.nodeStream(options.body)) {\n          options.body.destroy();\n        }\n        _this9.destroy(error);\n        return _possibleConstructorReturn(_this9);\n      }\n    }\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _a, normalizedURL, _iterator2, _step2, job;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            if (!(_this9.options.body instanceof fs_1.ReadStream)) {\n              _context2.next = 4;\n              break;\n            }\n            _context2.next = 4;\n            return waitForOpenFile(_this9.options.body);\n          case 4:\n            normalizedURL = _this9.options.url;\n            if (normalizedURL) {\n              _context2.next = 7;\n              break;\n            }\n            throw new TypeError('Missing `url` property');\n          case 7:\n            _this9.requestUrl = normalizedURL.toString();\n            decodeURI(_this9.requestUrl);\n            _context2.next = 11;\n            return _this9._finalizeBody();\n          case 11:\n            _context2.next = 13;\n            return _this9._makeRequest();\n          case 13:\n            if (!_this9.destroyed) {\n              _context2.next = 16;\n              break;\n            }\n            (_a = _this9[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();\n            return _context2.abrupt(\"return\");\n          case 16:\n            // Queued writes etc.\n            _iterator2 = _createForOfIteratorHelper(_this9[kJobs]);\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                job = _step2.value;\n                job();\n              }\n              // Prevent memory leak\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            _this9[kJobs].length = 0;\n            _this9.requestInitialized = true;\n            _context2.next = 28;\n            break;\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](0);\n            if (!(_context2.t0 instanceof RequestError)) {\n              _context2.next = 27;\n              break;\n            }\n            _this9._beforeError(_context2.t0);\n            return _context2.abrupt(\"return\");\n          case 27:\n            // This is a workaround for https://github.com/nodejs/node/issues/33335\n            if (!_this9.destroyed) {\n              _this9.destroy(_context2.t0);\n            }\n          case 28:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[0, 22]]);\n    }))();\n    return _this9;\n  }\n  _createClass(Request, [{\n    key: \"_lockWrite\",\n    value: function _lockWrite() {\n      var onLockedWrite = function onLockedWrite() {\n        throw new TypeError('The payload has been already provided');\n      };\n      this.write = onLockedWrite;\n      this.end = onLockedWrite;\n    }\n  }, {\n    key: \"_unlockWrite\",\n    value: function _unlockWrite() {\n      this.write = _get(_getPrototypeOf(Request.prototype), \"write\", this);\n      this.end = _get(_getPrototypeOf(Request.prototype), \"end\", this);\n    }\n  }, {\n    key: \"_finalizeBody\",\n    value: function () {\n      var _finalizeBody2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options, headers, isForm, isJSON, isBody, hasPayload, cannotHaveBody, noContentType, uploadBodySize;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = this.options;\n              headers = options.headers;\n              isForm = !is_1.default.undefined(options.form);\n              isJSON = !is_1.default.undefined(options.json);\n              isBody = !is_1.default.undefined(options.body);\n              hasPayload = isForm || isJSON || isBody;\n              cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n              this._cannotHaveBody = cannotHaveBody;\n              if (!hasPayload) {\n                _context3.next = 25;\n                break;\n              }\n              if (!cannotHaveBody) {\n                _context3.next = 11;\n                break;\n              }\n              throw new TypeError(\"The `\".concat(options.method, \"` method cannot be used with a body\"));\n            case 11:\n              if (!([isBody, isForm, isJSON].filter(function (isTrue) {\n                return isTrue;\n              }).length > 1)) {\n                _context3.next = 13;\n                break;\n              }\n              throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');\n            case 13:\n              if (!(isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body))) {\n                _context3.next = 15;\n                break;\n              }\n              throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n            case 15:\n              if (!(isForm && !is_1.default.object(options.form))) {\n                _context3.next = 17;\n                break;\n              }\n              throw new TypeError('The `form` option must be an Object');\n            case 17:\n              // Serialize body\n              noContentType = !is_1.default.string(headers['content-type']);\n              if (isBody) {\n                // Special case for https://github.com/form-data/form-data\n                if (is_form_data_1.default(options.body) && noContentType) {\n                  headers['content-type'] = \"multipart/form-data; boundary=\".concat(options.body.getBoundary());\n                }\n                this[kBody] = options.body;\n              } else if (isForm) {\n                if (noContentType) {\n                  headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                this[kBody] = new url_1.URLSearchParams(options.form).toString();\n              } else {\n                if (noContentType) {\n                  headers['content-type'] = 'application/json';\n                }\n                this[kBody] = options.stringifyJson(options.json);\n              }\n              _context3.next = 21;\n              return get_body_size_1.default(this[kBody], options.headers);\n            case 21:\n              uploadBodySize = _context3.sent;\n              // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n              // A user agent SHOULD send a Content-Length in a request message when\n              // no Transfer-Encoding is sent and the request method defines a meaning\n              // for an enclosed payload body.  For example, a Content-Length header\n              // field is normally sent in a POST request even when the value is 0\n              // (indicating an empty payload body).  A user agent SHOULD NOT send a\n              // Content-Length header field when the request message does not contain\n              // a payload body and the method semantics do not anticipate such a\n              // body.\n              if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {\n                if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {\n                  headers['content-length'] = String(uploadBodySize);\n                }\n              }\n              _context3.next = 26;\n              break;\n            case 25:\n              if (cannotHaveBody) {\n                this._lockWrite();\n              } else {\n                this._unlockWrite();\n              }\n            case 26:\n              this[kBodySize] = Number(headers['content-length']) || undefined;\n            case 27:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _finalizeBody() {\n        return _finalizeBody2.apply(this, arguments);\n      }\n      return _finalizeBody;\n    }()\n  }, {\n    key: \"_onResponseBase\",\n    value: function () {\n      var _onResponseBase2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(response) {\n        var _this10 = this;\n        var options, url, statusCode, typedResponse, rawCookies, promises, shouldBeGet, isUnixSocketURL, redirectBuffer, redirectUrl, redirectString, _iterator3, _step3, hook, _iterator4, _step4, destination, key, isAllowed, value;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              options = this.options;\n              url = options.url;\n              this[kOriginalResponse] = response;\n              if (options.decompress) {\n                response = decompressResponse(response);\n              }\n              statusCode = response.statusCode;\n              typedResponse = response;\n              typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n              typedResponse.url = options.url.toString();\n              typedResponse.requestUrl = this.requestUrl;\n              typedResponse.redirectUrls = this.redirects;\n              typedResponse.request = this;\n              typedResponse.isFromCache = response.fromCache || false;\n              typedResponse.ip = this.ip;\n              typedResponse.retryCount = this.retryCount;\n              this[kIsFromCache] = typedResponse.isFromCache;\n              this[kResponseSize] = Number(response.headers['content-length']) || undefined;\n              this[kResponse] = response;\n              response.once('end', function () {\n                _this10[kResponseSize] = _this10[kDownloadedSize];\n                _this10.emit('downloadProgress', _this10.downloadProgress);\n              });\n              response.once('error', function (error) {\n                // Force clean-up, because some packages don't do this.\n                // TODO: Fix decompress-response\n                response.destroy();\n                _this10._beforeError(new ReadError(error, _this10));\n              });\n              response.once('aborted', function () {\n                _this10._beforeError(new ReadError({\n                  name: 'Error',\n                  message: 'The server aborted pending request',\n                  code: 'ECONNRESET'\n                }, _this10));\n              });\n              this.emit('downloadProgress', this.downloadProgress);\n              rawCookies = response.headers['set-cookie'];\n              if (!(is_1.default.object(options.cookieJar) && rawCookies)) {\n                _context6.next = 34;\n                break;\n              }\n              promises = rawCookies.map( /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(rawCookie) {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        return _context4.abrupt(\"return\", options.cookieJar.setCookie(rawCookie, url.toString()));\n                      case 1:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }));\n                return function (_x3) {\n                  return _ref3.apply(this, arguments);\n                };\n              }());\n              if (options.ignoreInvalidCookies) {\n                promises = promises.map( /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(p) {\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) switch (_context5.prev = _context5.next) {\n                        case 0:\n                          return _context5.abrupt(\"return\", p.catch(function () {}));\n                        case 1:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }, _callee5);\n                  }));\n                  return function (_x4) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }());\n              }\n              _context6.prev = 25;\n              _context6.next = 28;\n              return Promise.all(promises);\n            case 28:\n              _context6.next = 34;\n              break;\n            case 30:\n              _context6.prev = 30;\n              _context6.t0 = _context6[\"catch\"](25);\n              this._beforeError(_context6.t0);\n              return _context6.abrupt(\"return\");\n            case 34:\n              if (!(options.followRedirect && response.headers.location && redirectCodes.has(statusCode))) {\n                _context6.next = 81;\n                break;\n              }\n              // We're being redirected, we don't care about the response.\n              // It'd be best to abort the request, but we can't because\n              // we would have to sacrifice the TCP connection. We don't want that.\n              response.resume();\n              if (this[kRequest]) {\n                this[kCancelTimeouts]();\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this[kRequest];\n                this[kUnproxyEvents]();\n              }\n              shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';\n              if (shouldBeGet || !options.methodRewriting) {\n                // Server responded with \"see other\", indicating that the resource exists at another location,\n                // and the client should request it from that location via GET or HEAD.\n                options.method = 'GET';\n                if ('body' in options) {\n                  delete options.body;\n                }\n                if ('json' in options) {\n                  delete options.json;\n                }\n                if ('form' in options) {\n                  delete options.form;\n                }\n                this[kBody] = undefined;\n                delete options.headers['content-length'];\n              }\n              if (!(this.redirects.length >= options.maxRedirects)) {\n                _context6.next = 42;\n                break;\n              }\n              this._beforeError(new MaxRedirectsError(this));\n              return _context6.abrupt(\"return\");\n            case 42:\n              _context6.prev = 42;\n              // eslint-disable-next-line no-inner-declarations\n              isUnixSocketURL = function isUnixSocketURL(url) {\n                return url.protocol === 'unix:' || url.hostname === 'unix';\n              };\n              // Do not remove. See https://github.com/sindresorhus/got/pull/214\n              redirectBuffer = Buffer.from(response.headers.location, 'binary').toString(); // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n              redirectUrl = new url_1.URL(redirectBuffer, url);\n              redirectString = redirectUrl.toString();\n              decodeURI(redirectString);\n              if (!(!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl))) {\n                _context6.next = 51;\n                break;\n              }\n              this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n              return _context6.abrupt(\"return\");\n            case 51:\n              // Redirecting to a different site, clear sensitive data.\n              if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                if ('host' in options.headers) {\n                  delete options.headers.host;\n                }\n                if ('cookie' in options.headers) {\n                  delete options.headers.cookie;\n                }\n                if ('authorization' in options.headers) {\n                  delete options.headers.authorization;\n                }\n                if (options.username || options.password) {\n                  options.username = '';\n                  options.password = '';\n                }\n              } else {\n                redirectUrl.username = options.username;\n                redirectUrl.password = options.password;\n              }\n              this.redirects.push(redirectString);\n              options.url = redirectUrl;\n              _iterator3 = _createForOfIteratorHelper(options.hooks.beforeRedirect);\n              _context6.prev = 55;\n              _iterator3.s();\n            case 57:\n              if ((_step3 = _iterator3.n()).done) {\n                _context6.next = 63;\n                break;\n              }\n              hook = _step3.value;\n              _context6.next = 61;\n              return hook(options, typedResponse);\n            case 61:\n              _context6.next = 57;\n              break;\n            case 63:\n              _context6.next = 68;\n              break;\n            case 65:\n              _context6.prev = 65;\n              _context6.t1 = _context6[\"catch\"](55);\n              _iterator3.e(_context6.t1);\n            case 68:\n              _context6.prev = 68;\n              _iterator3.f();\n              return _context6.finish(68);\n            case 71:\n              this.emit('redirect', typedResponse, options);\n              _context6.next = 74;\n              return this._makeRequest();\n            case 74:\n              _context6.next = 80;\n              break;\n            case 76:\n              _context6.prev = 76;\n              _context6.t2 = _context6[\"catch\"](42);\n              this._beforeError(_context6.t2);\n              return _context6.abrupt(\"return\");\n            case 80:\n              return _context6.abrupt(\"return\");\n            case 81:\n              if (!(options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse))) {\n                _context6.next = 84;\n                break;\n              }\n              this._beforeError(new HTTPError(typedResponse));\n              return _context6.abrupt(\"return\");\n            case 84:\n              response.on('readable', function () {\n                if (_this10[kTriggerRead]) {\n                  _this10._read();\n                }\n              });\n              this.on('resume', function () {\n                response.resume();\n              });\n              this.on('pause', function () {\n                response.pause();\n              });\n              response.once('end', function () {\n                _this10.push(null);\n              });\n              this.emit('response', response);\n              _iterator4 = _createForOfIteratorHelper(this[kServerResponsesPiped]);\n              _context6.prev = 90;\n              _iterator4.s();\n            case 92:\n              if ((_step4 = _iterator4.n()).done) {\n                _context6.next = 100;\n                break;\n              }\n              destination = _step4.value;\n              if (!destination.headersSent) {\n                _context6.next = 96;\n                break;\n              }\n              return _context6.abrupt(\"continue\", 98);\n            case 96:\n              // eslint-disable-next-line guard-for-in\n              for (key in response.headers) {\n                isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                value = response.headers[key];\n                if (isAllowed) {\n                  destination.setHeader(key, value);\n                }\n              }\n              destination.statusCode = statusCode;\n            case 98:\n              _context6.next = 92;\n              break;\n            case 100:\n              _context6.next = 105;\n              break;\n            case 102:\n              _context6.prev = 102;\n              _context6.t3 = _context6[\"catch\"](90);\n              _iterator4.e(_context6.t3);\n            case 105:\n              _context6.prev = 105;\n              _iterator4.f();\n              return _context6.finish(105);\n            case 108:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[25, 30], [42, 76], [55, 65, 68, 71], [90, 102, 105, 108]]);\n      }));\n      function _onResponseBase(_x2) {\n        return _onResponseBase2.apply(this, arguments);\n      }\n      return _onResponseBase;\n    }()\n  }, {\n    key: \"_onResponse\",\n    value: function () {\n      var _onResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(response) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return this._onResponseBase(response);\n            case 3:\n              _context7.next = 8;\n              break;\n            case 5:\n              _context7.prev = 5;\n              _context7.t0 = _context7[\"catch\"](0);\n              /* istanbul ignore next: better safe than sorry */\n              this._beforeError(_context7.t0);\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[0, 5]]);\n      }));\n      function _onResponse(_x5) {\n        return _onResponse2.apply(this, arguments);\n      }\n      return _onResponse;\n    }()\n  }, {\n    key: \"_onRequest\",\n    value: function _onRequest(request) {\n      var _this11 = this;\n      var options = this.options;\n      var timeout = options.timeout,\n        url = options.url;\n      http_timer_1.default(request);\n      this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);\n      var responseEventName = options.cache ? 'cacheableResponse' : 'response';\n      request.once(responseEventName, function (response) {\n        void _this11._onResponse(response);\n      });\n      request.once('error', function (error) {\n        var _a;\n        // Force clean-up, because some packages (e.g. nock) don't do this.\n        request.destroy();\n        // Node.js <= 12.18.2 mistakenly emits the response `end` first.\n        (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');\n        error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, _this11.timings, _this11) : new RequestError(error.message, error, _this11);\n        _this11._beforeError(error);\n      });\n      this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);\n      this[kRequest] = request;\n      this.emit('uploadProgress', this.uploadProgress);\n      // Send body\n      var body = this[kBody];\n      var currentRequest = this.redirects.length === 0 ? this : request;\n      if (is_1.default.nodeStream(body)) {\n        body.pipe(currentRequest);\n        body.once('error', function (error) {\n          _this11._beforeError(new UploadError(error, _this11));\n        });\n      } else {\n        this._unlockWrite();\n        if (!is_1.default.undefined(body)) {\n          this._writeRequest(body, undefined, function () {});\n          currentRequest.end();\n          this._lockWrite();\n        } else if (this._cannotHaveBody || this._noPipe) {\n          currentRequest.end();\n          this._lockWrite();\n        }\n      }\n      this.emit('request', request);\n    }\n  }, {\n    key: \"_createCacheableRequest\",\n    value: function () {\n      var _createCacheableRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(url, options) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", new Promise(function (resolve, reject) {\n                // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n                Object.assign(options, url_to_options_1.default(url));\n                // `http-cache-semantics` checks this\n                // TODO: Fix this ignore.\n                // @ts-expect-error\n                delete options.url;\n                var request;\n                // This is ugly\n                var cacheRequest = cacheableStore.get(options.cache)(options, /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(response) {\n                    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                      while (1) switch (_context8.prev = _context8.next) {\n                        case 0:\n                          // TODO: Fix `cacheable-response`\n                          response._readableState.autoDestroy = false;\n                          if (!request) {\n                            _context8.next = 5;\n                            break;\n                          }\n                          _context8.next = 4;\n                          return request;\n                        case 4:\n                          _context8.sent.emit('cacheableResponse', response);\n                        case 5:\n                          resolve(response);\n                        case 6:\n                        case \"end\":\n                          return _context8.stop();\n                      }\n                    }, _callee8);\n                  }));\n                  return function (_x8) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }());\n                // Restore options\n                options.url = url;\n                cacheRequest.once('error', reject);\n                cacheRequest.once('request', /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(requestOrPromise) {\n                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                      while (1) switch (_context9.prev = _context9.next) {\n                        case 0:\n                          request = requestOrPromise;\n                          resolve(request);\n                        case 2:\n                        case \"end\":\n                          return _context9.stop();\n                      }\n                    }, _callee9);\n                  }));\n                  return function (_x9) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }());\n              }));\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10);\n      }));\n      function _createCacheableRequest(_x6, _x7) {\n        return _createCacheableRequest2.apply(this, arguments);\n      }\n      return _createCacheableRequest;\n    }()\n  }, {\n    key: \"_makeRequest\",\n    value: function () {\n      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _this12 = this;\n        var _a, _b, _c, _d, _e, options, headers, key, cookieString, _iterator5, _step5, _loop, agent, request, timeout, url, matches, _matches$groups, socketPath, path, isHttps, fallbackFn, realFn, fn, requestOptions, requestOrResponse;\n        return _regeneratorRuntime().wrap(function _callee11$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              options = this.options;\n              headers = options.headers;\n              _context12.t0 = _regeneratorRuntime().keys(headers);\n            case 3:\n              if ((_context12.t1 = _context12.t0()).done) {\n                _context12.next = 13;\n                break;\n              }\n              key = _context12.t1.value;\n              if (!is_1.default.undefined(headers[key])) {\n                _context12.next = 9;\n                break;\n              }\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete headers[key];\n              _context12.next = 11;\n              break;\n            case 9:\n              if (!is_1.default.null_(headers[key])) {\n                _context12.next = 11;\n                break;\n              }\n              throw new TypeError(\"Use `undefined` instead of `null` to delete the `\".concat(key, \"` header\"));\n            case 11:\n              _context12.next = 3;\n              break;\n            case 13:\n              if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {\n                headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n              }\n              // Set cookies\n              if (!options.cookieJar) {\n                _context12.next = 19;\n                break;\n              }\n              _context12.next = 17;\n              return options.cookieJar.getCookieString(options.url.toString());\n            case 17:\n              cookieString = _context12.sent;\n              if (is_1.default.nonEmptyString(cookieString)) {\n                options.headers.cookie = cookieString;\n              }\n            case 19:\n              _iterator5 = _createForOfIteratorHelper(options.hooks.beforeRequest);\n              _context12.prev = 20;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var hook, result;\n                return _regeneratorRuntime().wrap(function _loop$(_context11) {\n                  while (1) switch (_context11.prev = _context11.next) {\n                    case 0:\n                      hook = _step5.value;\n                      _context11.next = 3;\n                      return hook(options);\n                    case 3:\n                      result = _context11.sent;\n                      if (is_1.default.undefined(result)) {\n                        _context11.next = 7;\n                        break;\n                      }\n                      // @ts-expect-error Skip the type mismatch to support abstract responses\n                      options.request = function () {\n                        return result;\n                      };\n                      return _context11.abrupt(\"return\", 1);\n                    case 7:\n                    case \"end\":\n                      return _context11.stop();\n                  }\n                }, _loop);\n              });\n              _iterator5.s();\n            case 23:\n              if ((_step5 = _iterator5.n()).done) {\n                _context12.next = 29;\n                break;\n              }\n              return _context12.delegateYield(_loop(), \"t2\", 25);\n            case 25:\n              if (!_context12.t2) {\n                _context12.next = 27;\n                break;\n              }\n              return _context12.abrupt(\"break\", 29);\n            case 27:\n              _context12.next = 23;\n              break;\n            case 29:\n              _context12.next = 34;\n              break;\n            case 31:\n              _context12.prev = 31;\n              _context12.t3 = _context12[\"catch\"](20);\n              _iterator5.e(_context12.t3);\n            case 34:\n              _context12.prev = 34;\n              _iterator5.f();\n              return _context12.finish(34);\n            case 37:\n              if (options.body && this[kBody] !== options.body) {\n                this[kBody] = options.body;\n              }\n              agent = options.agent, request = options.request, timeout = options.timeout, url = options.url;\n              if (options.dnsCache && !('lookup' in options)) {\n                options.lookup = options.dnsCache.lookup;\n              }\n              // UNIX sockets\n              if (url.hostname === 'unix') {\n                matches = /*#__PURE__*/_wrapRegExp(/(.+?):(.+)/, {\n                  socketPath: 1,\n                  path: 2\n                }).exec(\"\".concat(url.pathname).concat(url.search));\n                if (matches === null || matches === void 0 ? void 0 : matches.groups) {\n                  _matches$groups = matches.groups, socketPath = _matches$groups.socketPath, path = _matches$groups.path;\n                  Object.assign(options, {\n                    socketPath: socketPath,\n                    path: path,\n                    host: ''\n                  });\n                }\n              }\n              isHttps = url.protocol === 'https:'; // Fallback function\n              if (options.http2) {\n                fallbackFn = http2wrapper.auto;\n              } else {\n                fallbackFn = isHttps ? https.request : http.request;\n              }\n              realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn; // Cache support\n              fn = options.cache ? this._createCacheableRequest : realFn; // Pass an agent directly when HTTP2 is disabled\n              if (agent && !options.http2) {\n                options.agent = agent[isHttps ? 'https' : 'http'];\n              }\n              // Prepare plain HTTP request options\n              options[kRequest] = realFn;\n              delete options.request;\n              // TODO: Fix this ignore.\n              // @ts-expect-error\n              delete options.timeout;\n              requestOptions = options;\n              requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;\n              requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;\n              requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;\n              requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;\n              // If `dnsLookupIpVersion` is not present do not override `family`\n              if (!(options.dnsLookupIpVersion !== undefined)) {\n                _context12.next = 62;\n                break;\n              }\n              _context12.prev = 55;\n              requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);\n              _context12.next = 62;\n              break;\n            case 59:\n              _context12.prev = 59;\n              _context12.t4 = _context12[\"catch\"](55);\n              throw new Error('Invalid `dnsLookupIpVersion` option value');\n            case 62:\n              // HTTPS options remapping\n              if (options.https) {\n                if ('rejectUnauthorized' in options.https) {\n                  requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;\n                }\n                if (options.https.checkServerIdentity) {\n                  requestOptions.checkServerIdentity = options.https.checkServerIdentity;\n                }\n                if (options.https.certificateAuthority) {\n                  requestOptions.ca = options.https.certificateAuthority;\n                }\n                if (options.https.certificate) {\n                  requestOptions.cert = options.https.certificate;\n                }\n                if (options.https.key) {\n                  requestOptions.key = options.https.key;\n                }\n                if (options.https.passphrase) {\n                  requestOptions.passphrase = options.https.passphrase;\n                }\n                if (options.https.pfx) {\n                  requestOptions.pfx = options.https.pfx;\n                }\n              }\n              _context12.prev = 63;\n              _context12.next = 66;\n              return fn(url, requestOptions);\n            case 66:\n              requestOrResponse = _context12.sent;\n              if (is_1.default.undefined(requestOrResponse)) {\n                requestOrResponse = fallbackFn(url, requestOptions);\n              }\n              // Restore options\n              options.request = request;\n              options.timeout = timeout;\n              options.agent = agent;\n              // HTTPS options restore\n              if (options.https) {\n                if ('rejectUnauthorized' in options.https) {\n                  delete requestOptions.rejectUnauthorized;\n                }\n                if (options.https.checkServerIdentity) {\n                  // @ts-expect-error - This one will be removed when we remove the alias.\n                  delete requestOptions.checkServerIdentity;\n                }\n                if (options.https.certificateAuthority) {\n                  delete requestOptions.ca;\n                }\n                if (options.https.certificate) {\n                  delete requestOptions.cert;\n                }\n                if (options.https.key) {\n                  delete requestOptions.key;\n                }\n                if (options.https.passphrase) {\n                  delete requestOptions.passphrase;\n                }\n                if (options.https.pfx) {\n                  delete requestOptions.pfx;\n                }\n              }\n              if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n                // Emit the response after the stream has been ended\n              } else if (this.writable) {\n                this.once('finish', function () {\n                  void _this12._onResponse(requestOrResponse);\n                });\n                this._unlockWrite();\n                this.end();\n                this._lockWrite();\n              } else {\n                void this._onResponse(requestOrResponse);\n              }\n              _context12.next = 80;\n              break;\n            case 75:\n              _context12.prev = 75;\n              _context12.t5 = _context12[\"catch\"](63);\n              if (!(_context12.t5 instanceof CacheableRequest.CacheError)) {\n                _context12.next = 79;\n                break;\n              }\n              throw new CacheError(_context12.t5, this);\n            case 79:\n              throw new RequestError(_context12.t5.message, _context12.t5, this);\n            case 80:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee11, this, [[20, 31, 34, 37], [55, 59], [63, 75]]);\n      }));\n      function _makeRequest() {\n        return _makeRequest2.apply(this, arguments);\n      }\n      return _makeRequest;\n    }()\n  }, {\n    key: \"_error\",\n    value: function () {\n      var _error2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(error) {\n        var _iterator6, _step6, hook;\n        return _regeneratorRuntime().wrap(function _callee12$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.prev = 0;\n              _iterator6 = _createForOfIteratorHelper(this.options.hooks.beforeError);\n              _context13.prev = 2;\n              _iterator6.s();\n            case 4:\n              if ((_step6 = _iterator6.n()).done) {\n                _context13.next = 11;\n                break;\n              }\n              hook = _step6.value;\n              _context13.next = 8;\n              return hook(error);\n            case 8:\n              error = _context13.sent;\n            case 9:\n              _context13.next = 4;\n              break;\n            case 11:\n              _context13.next = 16;\n              break;\n            case 13:\n              _context13.prev = 13;\n              _context13.t0 = _context13[\"catch\"](2);\n              _iterator6.e(_context13.t0);\n            case 16:\n              _context13.prev = 16;\n              _iterator6.f();\n              return _context13.finish(16);\n            case 19:\n              _context13.next = 24;\n              break;\n            case 21:\n              _context13.prev = 21;\n              _context13.t1 = _context13[\"catch\"](0);\n              error = new RequestError(_context13.t1.message, _context13.t1, this);\n            case 24:\n              this.destroy(error);\n            case 25:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee12, this, [[0, 21], [2, 13, 16, 19]]);\n      }));\n      function _error(_x10) {\n        return _error2.apply(this, arguments);\n      }\n      return _error;\n    }()\n  }, {\n    key: \"_beforeError\",\n    value: function _beforeError(error) {\n      var _this13 = this;\n      if (this[kStopReading]) {\n        return;\n      }\n      var options = this.options;\n      var retryCount = this.retryCount + 1;\n      this[kStopReading] = true;\n      if (!(error instanceof RequestError)) {\n        error = new RequestError(error.message, error, this);\n      }\n      var typedError = error;\n      var response = typedError.response;\n      void _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var backoff, retryAfter, retry;\n        return _regeneratorRuntime().wrap(function _callee14$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!(response && !response.body)) {\n                _context15.next = 11;\n                break;\n              }\n              response.setEncoding(_this13._readableState.encoding);\n              _context15.prev = 2;\n              _context15.next = 5;\n              return get_buffer_1.default(response);\n            case 5:\n              response.rawBody = _context15.sent;\n              response.body = response.rawBody.toString();\n              _context15.next = 11;\n              break;\n            case 9:\n              _context15.prev = 9;\n              _context15.t0 = _context15[\"catch\"](2);\n            case 11:\n              if (!(_this13.listenerCount('retry') !== 0)) {\n                _context15.next = 27;\n                break;\n              }\n              _context15.prev = 12;\n              if (response && 'retry-after' in response.headers) {\n                retryAfter = Number(response.headers['retry-after']);\n                if (Number.isNaN(retryAfter)) {\n                  retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                  if (retryAfter <= 0) {\n                    retryAfter = 1;\n                  }\n                } else {\n                  retryAfter *= 1000;\n                }\n              }\n              _context15.next = 16;\n              return options.retry.calculateDelay({\n                attemptCount: retryCount,\n                retryOptions: options.retry,\n                error: typedError,\n                retryAfter: retryAfter,\n                computedValue: calculate_retry_delay_1.default({\n                  attemptCount: retryCount,\n                  retryOptions: options.retry,\n                  error: typedError,\n                  retryAfter: retryAfter,\n                  computedValue: 0\n                })\n              });\n            case 16:\n              backoff = _context15.sent;\n              _context15.next = 23;\n              break;\n            case 19:\n              _context15.prev = 19;\n              _context15.t1 = _context15[\"catch\"](12);\n              void _this13._error(new RequestError(_context15.t1.message, _context15.t1, _this13));\n              return _context15.abrupt(\"return\");\n            case 23:\n              if (!backoff) {\n                _context15.next = 27;\n                break;\n              }\n              retry = /*#__PURE__*/function () {\n                var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n                  var _iterator7, _step7, hook;\n                  return _regeneratorRuntime().wrap(function _callee13$(_context14) {\n                    while (1) switch (_context14.prev = _context14.next) {\n                      case 0:\n                        _context14.prev = 0;\n                        _iterator7 = _createForOfIteratorHelper(_this13.options.hooks.beforeRetry);\n                        _context14.prev = 2;\n                        _iterator7.s();\n                      case 4:\n                        if ((_step7 = _iterator7.n()).done) {\n                          _context14.next = 10;\n                          break;\n                        }\n                        hook = _step7.value;\n                        _context14.next = 8;\n                        return hook(_this13.options, typedError, retryCount);\n                      case 8:\n                        _context14.next = 4;\n                        break;\n                      case 10:\n                        _context14.next = 15;\n                        break;\n                      case 12:\n                        _context14.prev = 12;\n                        _context14.t0 = _context14[\"catch\"](2);\n                        _iterator7.e(_context14.t0);\n                      case 15:\n                        _context14.prev = 15;\n                        _iterator7.f();\n                        return _context14.finish(15);\n                      case 18:\n                        _context14.next = 24;\n                        break;\n                      case 20:\n                        _context14.prev = 20;\n                        _context14.t1 = _context14[\"catch\"](0);\n                        void _this13._error(new RequestError(_context14.t1.message, error, _this13));\n                        return _context14.abrupt(\"return\");\n                      case 24:\n                        if (!_this13.destroyed) {\n                          _context14.next = 26;\n                          break;\n                        }\n                        return _context14.abrupt(\"return\");\n                      case 26:\n                        _this13.destroy();\n                        _this13.emit('retry', retryCount, error);\n                      case 28:\n                      case \"end\":\n                        return _context14.stop();\n                    }\n                  }, _callee13, null, [[0, 20], [2, 12, 15, 18]]);\n                }));\n                return function retry() {\n                  return _ref8.apply(this, arguments);\n                };\n              }();\n              _this13[kRetryTimeout] = setTimeout(retry, backoff);\n              return _context15.abrupt(\"return\");\n            case 27:\n              void _this13._error(typedError);\n            case 28:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee14, null, [[2, 9], [12, 19]]);\n      }))();\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      this[kTriggerRead] = true;\n      var response = this[kResponse];\n      if (response && !this[kStopReading]) {\n        // We cannot put this in the `if` above\n        // because `.read()` also triggers the `end` event\n        if (response.readableLength) {\n          this[kTriggerRead] = false;\n        }\n        var data;\n        while ((data = response.read()) !== null) {\n          this[kDownloadedSize] += data.length;\n          this[kStartedReading] = true;\n          var progress = this.downloadProgress;\n          if (progress.percent < 1) {\n            this.emit('downloadProgress', progress);\n          }\n          this.push(data);\n        }\n      }\n    } // Node.js 12 has incorrect types, so the encoding must be a string\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      var _this14 = this;\n      var write = function write() {\n        _this14._writeRequest(chunk, encoding, callback);\n      };\n      if (this.requestInitialized) {\n        write();\n      } else {\n        this[kJobs].push(write);\n      }\n    }\n  }, {\n    key: \"_writeRequest\",\n    value: function _writeRequest(chunk, encoding, callback) {\n      var _this15 = this;\n      if (this[kRequest].destroyed) {\n        // Probably the `ClientRequest` instance will throw\n        return;\n      }\n      this._progressCallbacks.push(function () {\n        _this15[kUploadedSize] += Buffer.byteLength(chunk, encoding);\n        var progress = _this15.uploadProgress;\n        if (progress.percent < 1) {\n          _this15.emit('uploadProgress', progress);\n        }\n      });\n      // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.\n      this[kRequest].write(chunk, encoding, function (error) {\n        if (!error && _this15._progressCallbacks.length > 0) {\n          _this15._progressCallbacks.shift()();\n        }\n        callback(error);\n      });\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      var _this16 = this;\n      var endRequest = function endRequest() {\n        // FIX: Node.js 10 calls the write callback AFTER the end callback!\n        while (_this16._progressCallbacks.length !== 0) {\n          _this16._progressCallbacks.shift()();\n        }\n        // We need to check if `this[kRequest]` is present,\n        // because it isn't when we use cache.\n        if (!(kRequest in _this16)) {\n          callback();\n          return;\n        }\n        if (_this16[kRequest].destroyed) {\n          callback();\n          return;\n        }\n        _this16[kRequest].end(function (error) {\n          if (!error) {\n            _this16[kBodySize] = _this16[kUploadedSize];\n            _this16.emit('uploadProgress', _this16.uploadProgress);\n            _this16[kRequest].emit('upload-complete');\n          }\n          callback(error);\n        });\n      };\n      if (this.requestInitialized) {\n        endRequest();\n      } else {\n        this[kJobs].push(endRequest);\n      }\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(error, callback) {\n      var _a;\n      this[kStopReading] = true;\n      // Prevent further retries\n      clearTimeout(this[kRetryTimeout]);\n      if (kRequest in this) {\n        this[kCancelTimeouts]();\n        // TODO: Remove the next `if` when these get fixed:\n        // - https://github.com/nodejs/node/issues/32851\n        if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {\n          this[kRequest].destroy();\n        }\n      }\n      if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {\n        error = new RequestError(error.message, error, this);\n      }\n      callback(error);\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(destination, options) {\n      if (this[kStartedReading]) {\n        throw new Error('Failed to pipe. The response has been emitted already.');\n      }\n      if (destination instanceof http_1.ServerResponse) {\n        this[kServerResponsesPiped].add(destination);\n      }\n      return _get(_getPrototypeOf(Request.prototype), \"pipe\", this).call(this, destination, options);\n    }\n  }, {\n    key: \"unpipe\",\n    value: function unpipe(destination) {\n      if (destination instanceof http_1.ServerResponse) {\n        this[kServerResponsesPiped].delete(destination);\n      }\n      _get(_getPrototypeOf(Request.prototype), \"unpipe\", this).call(this, destination);\n      return this;\n    }\n  }, {\n    key: \"_isAboutToError\",\n    get: function get() {\n      return this[kStopReading];\n    }\n    /**\n    The remote IP address.\n    */\n  }, {\n    key: \"ip\",\n    get: function get() {\n      var _a;\n      return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n  }, {\n    key: \"aborted\",\n    get: function get() {\n      var _a, _b, _c;\n      return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);\n    }\n  }, {\n    key: \"socket\",\n    get: function get() {\n      var _a, _b;\n      return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n  }, {\n    key: \"downloadProgress\",\n    get: function get() {\n      var percent;\n      if (this[kResponseSize]) {\n        percent = this[kDownloadedSize] / this[kResponseSize];\n      } else if (this[kResponseSize] === this[kDownloadedSize]) {\n        percent = 1;\n      } else {\n        percent = 0;\n      }\n      return {\n        percent: percent,\n        transferred: this[kDownloadedSize],\n        total: this[kResponseSize]\n      };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n  }, {\n    key: \"uploadProgress\",\n    get: function get() {\n      var percent;\n      if (this[kBodySize]) {\n        percent = this[kUploadedSize] / this[kBodySize];\n      } else if (this[kBodySize] === this[kUploadedSize]) {\n        percent = 1;\n      } else {\n        percent = 0;\n      }\n      return {\n        percent: percent,\n        transferred: this[kUploadedSize],\n        total: this[kBodySize]\n      };\n    }\n    /**\n    The object contains the following properties:\n     - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n     If something has not been measured yet, it will be `undefined`.\n     __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n  }, {\n    key: \"timings\",\n    get: function get() {\n      var _a;\n      return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n  }, {\n    key: \"isFromCache\",\n    get: function get() {\n      return this[kIsFromCache];\n    }\n  }], [{\n    key: \"normalizeArguments\",\n    value: function normalizeArguments(url, options, defaults) {\n      var _a, _b, _c, _d, _e;\n      var rawOptions = options;\n      if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {\n        options = _objectSpread({}, defaults, url, options);\n      } else {\n        if (url && options && options.url !== undefined) {\n          throw new TypeError('The `url` option is mutually exclusive with the `input` argument');\n        }\n        options = _objectSpread({}, defaults, options);\n        if (url !== undefined) {\n          options.url = url;\n        }\n        if (is_1.default.urlInstance(options.url)) {\n          options.url = new url_1.URL(options.url.toString());\n        }\n      }\n      // TODO: Deprecate URL options in Got 12.\n      // Support extend-specific options\n      if (options.cache === false) {\n        options.cache = undefined;\n      }\n      if (options.dnsCache === false) {\n        options.dnsCache = undefined;\n      }\n      // Nice type assertions\n      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);\n      is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);\n      is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);\n      is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);\n      is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);\n      is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);\n      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);\n      is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);\n      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);\n      if (options.https) {\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);\n        is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);\n        is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);\n        is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);\n        is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);\n        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);\n        is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);\n      }\n      is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);\n      // `options.method`\n      if (is_1.default.string(options.method)) {\n        options.method = options.method.toUpperCase();\n      } else {\n        options.method = 'GET';\n      }\n      // `options.headers`\n      if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {\n        options.headers = _objectSpread({}, options.headers);\n      } else {\n        options.headers = lowercaseKeys(_objectSpread({}, defaults === null || defaults === void 0 ? void 0 : defaults.headers, options.headers));\n      }\n      // Disallow legacy `url.Url`\n      if ('slashes' in options) {\n        throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');\n      }\n      // `options.auth`\n      if ('auth' in options) {\n        throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n      }\n      // `options.searchParams`\n      if ('searchParams' in options) {\n        if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {\n          var searchParameters;\n          if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {\n            searchParameters = new url_1.URLSearchParams(options.searchParams);\n          } else {\n            validateSearchParameters(options.searchParams);\n            searchParameters = new url_1.URLSearchParams();\n            // eslint-disable-next-line guard-for-in\n            for (var key in options.searchParams) {\n              var value = options.searchParams[key];\n              if (value === null) {\n                searchParameters.append(key, '');\n              } else if (value !== undefined) {\n                searchParameters.append(key, value);\n              }\n            }\n          }\n          // `normalizeArguments()` is also used to merge options\n          (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach(function (value, key) {\n            // Only use default if one isn't already defined\n            if (!searchParameters.has(key)) {\n              searchParameters.append(key, value);\n            }\n          });\n          options.searchParams = searchParameters;\n        }\n      }\n      // `options.username` & `options.password`\n      options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';\n      options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';\n      // `options.prefixUrl` & `options.url`\n      if (is_1.default.undefined(options.prefixUrl)) {\n        options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';\n      } else {\n        options.prefixUrl = options.prefixUrl.toString();\n        if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {\n          options.prefixUrl += '/';\n        }\n      }\n      if (is_1.default.string(options.url)) {\n        if (options.url.startsWith('/')) {\n          throw new Error('`input` must not start with a slash when using `prefixUrl`');\n        }\n        options.url = options_to_url_1.default(options.prefixUrl + options.url, options);\n      } else if (is_1.default.undefined(options.url) && options.prefixUrl !== '' || options.protocol) {\n        options.url = options_to_url_1.default(options.prefixUrl, options);\n      }\n      if (options.url) {\n        if ('port' in options) {\n          delete options.port;\n        }\n        // Make it possible to change `options.prefixUrl`\n        var _options = options,\n          prefixUrl = _options.prefixUrl;\n        Object.defineProperty(options, 'prefixUrl', {\n          set: function set(value) {\n            var url = options.url;\n            if (!url.href.startsWith(value)) {\n              throw new Error(\"Cannot change `prefixUrl` from \".concat(prefixUrl, \" to \").concat(value, \": \").concat(url.href));\n            }\n            options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));\n            prefixUrl = value;\n          },\n          get: function get() {\n            return prefixUrl;\n          }\n        });\n        // Support UNIX sockets\n        var protocol = options.url.protocol;\n        if (protocol === 'unix:') {\n          protocol = 'http:';\n          options.url = new url_1.URL(\"http://unix\".concat(options.url.pathname).concat(options.url.search));\n        }\n        // Set search params\n        if (options.searchParams) {\n          // eslint-disable-next-line @typescript-eslint/no-base-to-string\n          options.url.search = options.searchParams.toString();\n        }\n        // Protocol check\n        if (protocol !== 'http:' && protocol !== 'https:') {\n          throw new UnsupportedProtocolError(options);\n        }\n        // Update `username`\n        if (options.username === '') {\n          options.username = options.url.username;\n        } else {\n          options.url.username = options.username;\n        }\n        // Update `password`\n        if (options.password === '') {\n          options.password = options.url.password;\n        } else {\n          options.url.password = options.password;\n        }\n      }\n      // `options.cookieJar`\n      var _options2 = options,\n        cookieJar = _options2.cookieJar;\n      if (cookieJar) {\n        var setCookie = cookieJar.setCookie,\n          getCookieString = cookieJar.getCookieString;\n        is_1.assert.function_(setCookie);\n        is_1.assert.function_(getCookieString);\n        /* istanbul ignore next: Horrible `tough-cookie` v3 check */\n        if (setCookie.length === 4 && getCookieString.length === 0) {\n          setCookie = util_1.promisify(setCookie.bind(options.cookieJar));\n          getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));\n          options.cookieJar = {\n            setCookie: setCookie,\n            getCookieString: getCookieString\n          };\n        }\n      }\n      // `options.cache`\n      var _options3 = options,\n        cache = _options3.cache;\n      if (cache) {\n        if (!cacheableStore.has(cache)) {\n          cacheableStore.set(cache, new CacheableRequest(function (requestOptions, handler) {\n            var result = requestOptions[kRequest](requestOptions, handler);\n            // TODO: remove this when `cacheable-request` supports async request functions.\n            if (is_1.default.promise(result)) {\n              // @ts-expect-error\n              // We only need to implement the error handler in order to support HTTP2 caching.\n              // The result will be a promise anyway.\n              result.once = function (event, handler) {\n                if (event === 'error') {\n                  result.catch(handler);\n                } else if (event === 'abort') {\n                  // The empty catch is needed here in case when\n                  // it rejects before it's `await`ed in `_makeRequest`.\n                  _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                    var request;\n                    return _regeneratorRuntime().wrap(function _callee15$(_context16) {\n                      while (1) switch (_context16.prev = _context16.next) {\n                        case 0:\n                          _context16.prev = 0;\n                          _context16.next = 3;\n                          return result;\n                        case 3:\n                          request = _context16.sent;\n                          request.once('abort', handler);\n                          _context16.next = 9;\n                          break;\n                        case 7:\n                          _context16.prev = 7;\n                          _context16.t0 = _context16[\"catch\"](0);\n                        case 9:\n                        case \"end\":\n                          return _context16.stop();\n                      }\n                    }, _callee15, null, [[0, 7]]);\n                  }))();\n                } else {\n                  /* istanbul ignore next: safety check */\n                  throw new Error(\"Unknown HTTP2 promise event: \".concat(event));\n                }\n                return result;\n              };\n            }\n            return result;\n          }, cache));\n        }\n      }\n      // `options.cacheOptions`\n      options.cacheOptions = _objectSpread({}, options.cacheOptions);\n      // `options.dnsCache`\n      if (options.dnsCache === true) {\n        if (!globalDnsCache) {\n          globalDnsCache = new cacheable_lookup_1.default();\n        }\n        options.dnsCache = globalDnsCache;\n      } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {\n        throw new TypeError(\"Parameter `dnsCache` must be a CacheableLookup instance or a boolean, got \".concat(is_1.default(options.dnsCache)));\n      }\n      // `options.timeout`\n      if (is_1.default.number(options.timeout)) {\n        options.timeout = {\n          request: options.timeout\n        };\n      } else if (defaults && options.timeout !== defaults.timeout) {\n        options.timeout = _objectSpread({}, defaults.timeout, options.timeout);\n      } else {\n        options.timeout = _objectSpread({}, options.timeout);\n      }\n      // `options.context`\n      if (!options.context) {\n        options.context = {};\n      }\n      // `options.hooks`\n      var areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);\n      options.hooks = _objectSpread({}, options.hooks);\n      var _iterator8 = _createForOfIteratorHelper(exports.knownHookEvents),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _event = _step8.value;\n          if (_event in options.hooks) {\n            if (is_1.default.array(options.hooks[_event])) {\n              // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n              options.hooks[_event] = _toConsumableArray(options.hooks[_event]);\n            } else {\n              throw new TypeError(\"Parameter `\".concat(_event, \"` must be an Array, got \").concat(is_1.default(options.hooks[_event])));\n            }\n          } else {\n            options.hooks[_event] = [];\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      if (defaults && !areHooksDefault) {\n        var _iterator9 = _createForOfIteratorHelper(exports.knownHookEvents),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var event = _step9.value;\n            var defaultHooks = defaults.hooks[event];\n            if (defaultHooks.length > 0) {\n              // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n              options.hooks[event] = [].concat(_toConsumableArray(defaults.hooks[event]), _toConsumableArray(options.hooks[event]));\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n      // DNS options\n      if ('family' in options) {\n        deprecation_warning_1.default('\"options.family\" was never documented, please use \"options.dnsLookupIpVersion\"');\n      }\n      // HTTPS options\n      if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {\n        options.https = _objectSpread({}, defaults.https, options.https);\n      }\n      if ('rejectUnauthorized' in options) {\n        deprecation_warning_1.default('\"options.rejectUnauthorized\" is now deprecated, please use \"options.https.rejectUnauthorized\"');\n      }\n      if ('checkServerIdentity' in options) {\n        deprecation_warning_1.default('\"options.checkServerIdentity\" was never documented, please use \"options.https.checkServerIdentity\"');\n      }\n      if ('ca' in options) {\n        deprecation_warning_1.default('\"options.ca\" was never documented, please use \"options.https.certificateAuthority\"');\n      }\n      if ('key' in options) {\n        deprecation_warning_1.default('\"options.key\" was never documented, please use \"options.https.key\"');\n      }\n      if ('cert' in options) {\n        deprecation_warning_1.default('\"options.cert\" was never documented, please use \"options.https.certificate\"');\n      }\n      if ('passphrase' in options) {\n        deprecation_warning_1.default('\"options.passphrase\" was never documented, please use \"options.https.passphrase\"');\n      }\n      if ('pfx' in options) {\n        deprecation_warning_1.default('\"options.pfx\" was never documented, please use \"options.https.pfx\"');\n      }\n      // Other options\n      if ('followRedirects' in options) {\n        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');\n      }\n      if (options.agent) {\n        for (var _key in options.agent) {\n          if (_key !== 'http' && _key !== 'https' && _key !== 'http2') {\n            throw new TypeError(\"Expected the `options.agent` properties to be `http`, `https` or `http2`, got `\".concat(_key, \"`\"));\n          }\n        }\n      }\n      options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;\n      // Set non-enumerable properties\n      exports.setNonEnumerableProperties([defaults, rawOptions], options);\n      return normalize_arguments_1.default(options, defaults);\n    }\n  }]);\n  return Request;\n}(stream_1.Duplex);\nexports.default = Request;","map":null,"metadata":{},"sourceType":"script"}