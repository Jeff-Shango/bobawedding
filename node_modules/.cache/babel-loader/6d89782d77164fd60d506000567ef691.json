{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar EventEmitter = require('events');\nvar tls = require('tls');\nvar http2 = require('http2');\nvar QuickLRU = require('quick-lru');\nvar kCurrentStreamsCount = Symbol('currentStreamsCount');\nvar kRequest = Symbol('request');\nvar kOriginSet = Symbol('cachedOriginSet');\nvar kGracefullyClosing = Symbol('gracefullyClosing');\nvar nameKeys = [\n// `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy',\n// `tls.connect()` options\n'localAddress', 'path', 'rejectUnauthorized', 'minDHSize',\n// `tls.createSecureContext()` options\n'ca', 'cert', 'clientCertEngine', 'ciphers', 'key', 'pfx', 'servername', 'minVersion', 'maxVersion', 'secureProtocol', 'crl', 'honorCipherOrder', 'ecdhCurve', 'dhparam', 'secureOptions', 'sessionIdContext'];\nvar getSortedIndex = function getSortedIndex(array, value, compare) {\n  var low = 0;\n  var high = array.length;\n  while (low < high) {\n    var mid = low + high >>> 1;\n\n    /* istanbul ignore next */\n    if (compare(array[mid], value)) {\n      // This never gets called because we use descending sort. Better to have this anyway.\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\nvar compareSessions = function compareSessions(a, b) {\n  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nvar closeCoveredSessions = function closeCoveredSessions(where, session) {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  var _iterator = _createForOfIteratorHelper(where),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var coveredSession = _step.value;\n      if (\n      // The set is a proper subset when its length is less than the other set.\n      coveredSession[kOriginSet].length < session[kOriginSet].length &&\n      // And the other set includes all elements of the subset.\n      coveredSession[kOriginSet].every(function (origin) {\n        return session[kOriginSet].includes(origin);\n      }) &&\n      // Makes sure that the session can handle all requests from the covered session.\n      coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n        // This allows pending requests to finish and prevents making new requests.\n        gracefullyClose(coveredSession);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nvar closeSessionIfCovered = function closeSessionIfCovered(where, coveredSession) {\n  var _iterator2 = _createForOfIteratorHelper(where),\n    _step2;\n  try {\n    var _loop = function _loop() {\n      var session = _step2.value;\n      if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(function (origin) {\n        return session[kOriginSet].includes(origin);\n      }) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n        gracefullyClose(coveredSession);\n      }\n    };\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nvar getSessions = function getSessions(_ref) {\n  var agent = _ref.agent,\n    isFree = _ref.isFree;\n  var result = {};\n\n  // eslint-disable-next-line guard-for-in\n  for (var normalizedOptions in agent.sessions) {\n    var sessions = agent.sessions[normalizedOptions];\n    var filtered = sessions.filter(function (session) {\n      var result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n      return isFree ? result : !result;\n    });\n    if (filtered.length !== 0) {\n      result[normalizedOptions] = filtered;\n    }\n  }\n  return result;\n};\nvar gracefullyClose = function gracefullyClose(session) {\n  session[kGracefullyClosing] = true;\n  if (session[kCurrentStreamsCount] === 0) {\n    session.close();\n  }\n};\nvar Agent = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Agent, _EventEmitter);\n  function Agent() {\n    var _this;\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref2$timeout = _ref2.timeout,\n      timeout = _ref2$timeout === void 0 ? 60000 : _ref2$timeout,\n      _ref2$maxSessions = _ref2.maxSessions,\n      maxSessions = _ref2$maxSessions === void 0 ? Infinity : _ref2$maxSessions,\n      _ref2$maxFreeSessions = _ref2.maxFreeSessions,\n      maxFreeSessions = _ref2$maxFreeSessions === void 0 ? 10 : _ref2$maxFreeSessions,\n      _ref2$maxCachedTlsSes = _ref2.maxCachedTlsSessions,\n      maxCachedTlsSessions = _ref2$maxCachedTlsSes === void 0 ? 100 : _ref2$maxCachedTlsSes;\n    _classCallCheck(this, Agent);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Agent).call(this));\n\n    // A session is considered busy when its current streams count\n    // is equal to or greater than the `maxConcurrentStreams` value.\n\n    // A session is considered free when its current streams count\n    // is less than the `maxConcurrentStreams` value.\n\n    // SESSIONS[NORMALIZED_OPTIONS] = [];\n    _this.sessions = {};\n\n    // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n    _this.queue = {};\n\n    // Each session will use this timeout value.\n    _this.timeout = timeout;\n\n    // Max sessions in total\n    _this.maxSessions = maxSessions;\n\n    // Max free sessions in total\n    // TODO: decreasing `maxFreeSessions` should close some sessions\n    _this.maxFreeSessions = maxFreeSessions;\n    _this._freeSessionsCount = 0;\n    _this._sessionsCount = 0;\n\n    // We don't support push streams by default.\n    _this.settings = {\n      enablePush: false\n    };\n\n    // Reusing TLS sessions increases performance.\n    _this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n    return _this;\n  }\n  _createClass(Agent, [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions(options) {\n      var normalized = '';\n      if (options) {\n        for (var _i = 0, _nameKeys = nameKeys; _i < _nameKeys.length; _i++) {\n          var key = _nameKeys[_i];\n          if (options[key]) {\n            normalized += \":\".concat(options[key]);\n          }\n        }\n      }\n      return normalized;\n    }\n  }, {\n    key: \"_tryToCreateNewSession\",\n    value: function _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n      if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n        return;\n      }\n      var item = this.queue[normalizedOptions][normalizedOrigin];\n\n      // The entry function can be run only once.\n      // BUG: The session may be never created when:\n      // - the first condition is false AND\n      // - this function is never called with the same arguments in the future.\n      if (this._sessionsCount < this.maxSessions && !item.completed) {\n        item.completed = true;\n        item();\n      }\n    }\n  }, {\n    key: \"getSession\",\n    value: function getSession(origin, options, listeners) {\n      var _this2 = this;\n      return new Promise(function (resolve, reject) {\n        if (Array.isArray(listeners)) {\n          listeners = _toConsumableArray(listeners);\n\n          // Resolve the current promise ASAP, we're just moving the listeners.\n          // They will be executed at a different time.\n          resolve();\n        } else {\n          listeners = [{\n            resolve: resolve,\n            reject: reject\n          }];\n        }\n        var normalizedOptions = _this2.normalizeOptions(options);\n        var normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n        if (normalizedOrigin === undefined) {\n          var _iterator3 = _createForOfIteratorHelper(listeners),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _reject = _step3.value.reject;\n              _reject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return;\n        }\n        if (normalizedOptions in _this2.sessions) {\n          var sessions = _this2.sessions[normalizedOptions];\n          var maxConcurrentStreams = -1;\n          var currentStreamsCount = -1;\n          var optimalSession;\n\n          // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n          // Additionally, we are looking for session which has biggest current pending streams count.\n          var _iterator4 = _createForOfIteratorHelper(sessions),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var session = _step4.value;\n              var sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n                break;\n              }\n              if (session[kOriginSet].includes(normalizedOrigin)) {\n                var sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] ||\n                // Unfortunately the `close` event isn't called immediately,\n                // so `session.destroyed` is `true`, but `session.closed` is `false`.\n                session.destroyed) {\n                  continue;\n                }\n\n                // We only need set this once.\n                if (!optimalSession) {\n                  maxConcurrentStreams = sessionMaxConcurrentStreams;\n                }\n\n                // We're looking for the session which has biggest current pending stream count,\n                // in order to minimalize the amount of active sessions.\n                if (sessionCurrentStreamsCount > currentStreamsCount) {\n                  optimalSession = session;\n                  currentStreamsCount = sessionCurrentStreamsCount;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          if (optimalSession) {\n            /* istanbul ignore next: safety check */\n            if (listeners.length !== 1) {\n              var _iterator5 = _createForOfIteratorHelper(listeners),\n                _step5;\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _reject2 = _step5.value.reject;\n                  var error = new Error(\"Expected the length of listeners to be 1, got \".concat(listeners.length, \".\\n\") + 'Please report this to https://github.com/szmarczak/http2-wrapper/');\n                  _reject2(error);\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              return;\n            }\n            listeners[0].resolve(optimalSession);\n            return;\n          }\n        }\n        if (normalizedOptions in _this2.queue) {\n          if (normalizedOrigin in _this2.queue[normalizedOptions]) {\n            var _this2$queue$normaliz;\n            // There's already an item in the queue, just attach ourselves to it.\n            (_this2$queue$normaliz = _this2.queue[normalizedOptions][normalizedOrigin].listeners).push.apply(_this2$queue$normaliz, _toConsumableArray(listeners));\n\n            // This shouldn't be executed here.\n            // See the comment inside _tryToCreateNewSession.\n            _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n            return;\n          }\n        } else {\n          _this2.queue[normalizedOptions] = {};\n        }\n\n        // The entry must be removed from the queue IMMEDIATELY when:\n        // 1. the session connects successfully,\n        // 2. an error occurs.\n        var removeFromQueue = function removeFromQueue() {\n          // Our entry can be replaced. We cannot remove the new one.\n          if (normalizedOptions in _this2.queue && _this2.queue[normalizedOptions][normalizedOrigin] === entry) {\n            delete _this2.queue[normalizedOptions][normalizedOrigin];\n            if (Object.keys(_this2.queue[normalizedOptions]).length === 0) {\n              delete _this2.queue[normalizedOptions];\n            }\n          }\n        };\n\n        // The main logic is here\n        var entry = function entry() {\n          var name = \"\".concat(normalizedOrigin, \":\").concat(normalizedOptions);\n          var receivedSettings = false;\n          try {\n            var _session = http2.connect(origin, _objectSpread({\n              createConnection: _this2.createConnection,\n              settings: _this2.settings,\n              session: _this2.tlsSessionCache.get(name)\n            }, options));\n            _session[kCurrentStreamsCount] = 0;\n            _session[kGracefullyClosing] = false;\n            var isFree = function isFree() {\n              return _session[kCurrentStreamsCount] < _session.remoteSettings.maxConcurrentStreams;\n            };\n            var wasFree = true;\n            _session.socket.once('session', function (tlsSession) {\n              _this2.tlsSessionCache.set(name, tlsSession);\n            });\n            _session.once('error', function (error) {\n              // Listeners are empty when the session successfully connected.\n              var _iterator6 = _createForOfIteratorHelper(listeners),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _reject3 = _step6.value.reject;\n                  _reject3(error);\n                }\n\n                // The connection got broken, purge the cache.\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              _this2.tlsSessionCache.delete(name);\n            });\n            _session.setTimeout(_this2.timeout, function () {\n              // Terminates all streams owned by this session.\n              // TODO: Maybe the streams should have a \"Session timed out\" error?\n              _session.destroy();\n            });\n            _session.once('close', function () {\n              if (receivedSettings) {\n                // 1. If it wasn't free then no need to decrease because\n                //    it has been decreased already in session.request().\n                // 2. `stream.once('close')` won't increment the count\n                //    because the session is already closed.\n                if (wasFree) {\n                  _this2._freeSessionsCount--;\n                }\n                _this2._sessionsCount--;\n\n                // This cannot be moved to the stream logic,\n                // because there may be a session that hadn't made a single request.\n                var where = _this2.sessions[normalizedOptions];\n                where.splice(where.indexOf(_session), 1);\n                if (where.length === 0) {\n                  delete _this2.sessions[normalizedOptions];\n                }\n              } else {\n                // Broken connection\n                var _error = new Error('Session closed without receiving a SETTINGS frame');\n                _error.code = 'HTTP2WRAPPER_NOSETTINGS';\n                var _iterator7 = _createForOfIteratorHelper(listeners),\n                  _step7;\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    var _reject4 = _step7.value.reject;\n                    _reject4(_error);\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n                removeFromQueue();\n              }\n\n              // There may be another session awaiting.\n              _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n            });\n\n            // Iterates over the queue and processes listeners.\n            var processListeners = function processListeners() {\n              if (!(normalizedOptions in _this2.queue) || !isFree()) {\n                return;\n              }\n              var _iterator8 = _createForOfIteratorHelper(_session[kOriginSet]),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var _origin = _step8.value;\n                  if (_origin in _this2.queue[normalizedOptions]) {\n                    var _listeners = _this2.queue[normalizedOptions][_origin].listeners; // Prevents session overloading.\n                    while (_listeners.length !== 0 && isFree()) {\n                      // We assume `resolve(...)` calls `request(...)` *directly*,\n                      // otherwise the session will get overloaded.\n                      _listeners.shift().resolve(_session);\n                    }\n                    var where = _this2.queue[normalizedOptions];\n                    if (where[_origin].listeners.length === 0) {\n                      delete where[_origin];\n                      if (Object.keys(where).length === 0) {\n                        delete _this2.queue[normalizedOptions];\n                        break;\n                      }\n                    }\n\n                    // We're no longer free, no point in continuing.\n                    if (!isFree()) {\n                      break;\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            };\n\n            // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n            _session.on('origin', function () {\n              _session[kOriginSet] = _session.originSet;\n              if (!isFree()) {\n                // The session is full.\n                return;\n              }\n              processListeners();\n\n              // Close covered sessions (if possible).\n              closeCoveredSessions(_this2.sessions[normalizedOptions], _session);\n            });\n            _session.once('remoteSettings', function () {\n              // Fix Node.js bug preventing the process from exiting\n              _session.ref();\n              _session.unref();\n              _this2._sessionsCount++;\n\n              // The Agent could have been destroyed already.\n              if (entry.destroyed) {\n                var _error2 = new Error('Agent has been destroyed');\n                var _iterator9 = _createForOfIteratorHelper(listeners),\n                  _step9;\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var listener = _step9.value;\n                    listener.reject(_error2);\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n                _session.destroy();\n                return;\n              }\n              _session[kOriginSet] = _session.originSet;\n              {\n                var where = _this2.sessions;\n                if (normalizedOptions in where) {\n                  var _sessions = where[normalizedOptions];\n                  _sessions.splice(getSortedIndex(_sessions, _session, compareSessions), 0, _session);\n                } else {\n                  where[normalizedOptions] = [_session];\n                }\n              }\n              _this2._freeSessionsCount += 1;\n              receivedSettings = true;\n              _this2.emit('session', _session);\n              processListeners();\n              removeFromQueue();\n\n              // TODO: Close last recently used (or least used?) session\n              if (_session[kCurrentStreamsCount] === 0 && _this2._freeSessionsCount > _this2.maxFreeSessions) {\n                _session.close();\n              }\n\n              // Check if we haven't managed to execute all listeners.\n              if (listeners.length !== 0) {\n                // Request for a new session with predefined listeners.\n                _this2.getSession(normalizedOrigin, options, listeners);\n                listeners.length = 0;\n              }\n\n              // `session.remoteSettings.maxConcurrentStreams` might get increased\n              _session.on('remoteSettings', function () {\n                processListeners();\n\n                // In case the Origin Set changes\n                closeCoveredSessions(_this2.sessions[normalizedOptions], _session);\n              });\n            });\n\n            // Shim `session.request()` in order to catch all streams\n            _session[kRequest] = _session.request;\n            _session.request = function (headers, streamOptions) {\n              if (_session[kGracefullyClosing]) {\n                throw new Error('The session is gracefully closing. No new streams are allowed.');\n              }\n              var stream = _session[kRequest](headers, streamOptions);\n\n              // The process won't exit until the session is closed or all requests are gone.\n              _session.ref();\n              ++_session[kCurrentStreamsCount];\n              if (_session[kCurrentStreamsCount] === _session.remoteSettings.maxConcurrentStreams) {\n                _this2._freeSessionsCount--;\n              }\n              stream.once('close', function () {\n                wasFree = isFree();\n                --_session[kCurrentStreamsCount];\n                if (!_session.destroyed && !_session.closed) {\n                  closeSessionIfCovered(_this2.sessions[normalizedOptions], _session);\n                  if (isFree() && !_session.closed) {\n                    if (!wasFree) {\n                      _this2._freeSessionsCount++;\n                      wasFree = true;\n                    }\n                    var isEmpty = _session[kCurrentStreamsCount] === 0;\n                    if (isEmpty) {\n                      _session.unref();\n                    }\n                    if (isEmpty && (_this2._freeSessionsCount > _this2.maxFreeSessions || _session[kGracefullyClosing])) {\n                      _session.close();\n                    } else {\n                      closeCoveredSessions(_this2.sessions[normalizedOptions], _session);\n                      processListeners();\n                    }\n                  }\n                }\n              });\n              return stream;\n            };\n          } catch (error) {\n            var _iterator10 = _createForOfIteratorHelper(listeners),\n              _step10;\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var listener = _step10.value;\n                listener.reject(error);\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n            removeFromQueue();\n          }\n        };\n        entry.listeners = listeners;\n        entry.completed = false;\n        entry.destroyed = false;\n        _this2.queue[normalizedOptions][normalizedOrigin] = entry;\n        _this2._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n      });\n    }\n  }, {\n    key: \"request\",\n    value: function request(origin, options, headers, streamOptions) {\n      var _this3 = this;\n      return new Promise(function (_resolve, reject) {\n        _this3.getSession(origin, options, [{\n          reject: reject,\n          resolve: function resolve(session) {\n            try {\n              _resolve(session.request(headers, streamOptions));\n            } catch (error) {\n              reject(error);\n            }\n          }\n        }]);\n      });\n    }\n  }, {\n    key: \"createConnection\",\n    value: function createConnection(origin, options) {\n      return Agent.connect(origin, options);\n    }\n  }, {\n    key: \"closeFreeSessions\",\n    value: function closeFreeSessions() {\n      for (var _i2 = 0, _Object$values = Object.values(this.sessions); _i2 < _Object$values.length; _i2++) {\n        var sessions = _Object$values[_i2];\n        var _iterator11 = _createForOfIteratorHelper(sessions),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var session = _step11.value;\n            if (session[kCurrentStreamsCount] === 0) {\n              session.close();\n            }\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(reason) {\n      for (var _i3 = 0, _Object$values2 = Object.values(this.sessions); _i3 < _Object$values2.length; _i3++) {\n        var sessions = _Object$values2[_i3];\n        var _iterator12 = _createForOfIteratorHelper(sessions),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var session = _step12.value;\n            session.destroy(reason);\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n      for (var _i4 = 0, _Object$values3 = Object.values(this.queue); _i4 < _Object$values3.length; _i4++) {\n        var entriesOfAuthority = _Object$values3[_i4];\n        for (var _i5 = 0, _Object$values4 = Object.values(entriesOfAuthority); _i5 < _Object$values4.length; _i5++) {\n          var entry = _Object$values4[_i5];\n          entry.destroyed = true;\n        }\n      }\n\n      // New requests should NOT attach to destroyed sessions\n      this.queue = {};\n    }\n  }, {\n    key: \"freeSessions\",\n    get: function get() {\n      return getSessions({\n        agent: this,\n        isFree: true\n      });\n    }\n  }, {\n    key: \"busySessions\",\n    get: function get() {\n      return getSessions({\n        agent: this,\n        isFree: false\n      });\n    }\n  }], [{\n    key: \"normalizeOrigin\",\n    value: function normalizeOrigin(url, servername) {\n      if (typeof url === 'string') {\n        url = new URL(url);\n      }\n      if (servername && url.hostname !== servername) {\n        url.hostname = servername;\n      }\n      return url.origin;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(origin, options) {\n      options.ALPNProtocols = ['h2'];\n      var port = origin.port || 443;\n      var host = origin.hostname || origin.host;\n      if (typeof options.servername === 'undefined') {\n        options.servername = host;\n      }\n      return tls.connect(port, host, options);\n    }\n  }]);\n  return Agent;\n}(EventEmitter);\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent: Agent,\n  globalAgent: new Agent()\n};","map":null,"metadata":{},"sourceType":"script"}