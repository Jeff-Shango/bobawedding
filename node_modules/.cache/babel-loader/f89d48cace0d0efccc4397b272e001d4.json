{"ast":null,"code":"var _require = require('assert'),\n  assert = _require.strict;\nvar _require2 = require('crypto'),\n  createHash = _require2.createHash;\nvar _require3 = require('util'),\n  format = _require3.format;\nvar shake256 = require('./shake256');\nvar encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = function encode(input) {\n    return input.toString('base64url');\n  };\n} else {\n  var fromBase64 = function fromBase64(base64) {\n    return base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  };\n  encode = function encode(input) {\n    return fromBase64(input.toString('base64'));\n  };\n}\n\n/** SPECIFICATION\n * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of\n * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm\n * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is\n * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode\n * them. The _hash value is a case sensitive string.\n */\n\n/**\n * @name getHash\n * @api private\n *\n * returns the sha length based off the JOSE alg heade value, defaults to sha256\n *\n * @param token {String} token value to generate the hash from\n * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)\n * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA\n */\nfunction getHash(alg, crv) {\n  switch (alg) {\n    case 'HS256':\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n    case 'ES256K':\n      return createHash('sha256');\n    case 'HS384':\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      return createHash('sha384');\n    case 'HS512':\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      return createHash('sha512');\n    case 'EdDSA':\n      switch (crv) {\n        case 'Ed25519':\n          return createHash('sha512');\n        case 'Ed448':\n          if (!shake256) {\n            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');\n          }\n          return createHash('shake256', {\n            outputLength: 114\n          });\n        default:\n          throw new TypeError('unrecognized or invalid EdDSA curve provided');\n      }\n    default:\n      throw new TypeError('unrecognized or invalid JWS algorithm provided');\n  }\n}\nfunction generate(token, alg, crv) {\n  var digest = getHash(alg, crv).update(token).digest();\n  return encode(digest.slice(0, digest.length / 2));\n}\nfunction validate(names, actual, source, alg, crv) {\n  if (typeof names.claim !== 'string' || !names.claim) {\n    throw new TypeError('names.claim must be a non-empty string');\n  }\n  if (typeof names.source !== 'string' || !names.source) {\n    throw new TypeError('names.source must be a non-empty string');\n  }\n  assert(typeof actual === 'string' && actual, \"\".concat(names.claim, \" must be a non-empty string\"));\n  assert(typeof source === 'string' && source, \"\".concat(names.source, \" must be a non-empty string\"));\n  var expected;\n  var msg;\n  try {\n    expected = generate(source, alg, crv);\n  } catch (err) {\n    msg = format('%s could not be validated (%s)', names.claim, err.message);\n  }\n  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);\n  assert.equal(expected, actual, msg);\n}\nmodule.exports = {\n  validate: validate,\n  generate: generate\n};","map":null,"metadata":{},"sourceType":"script"}