{"ast":null,"code":"'use strict';\n\n/**\n * @file\n *\n * Copyright 2018 FutoIn Project (https://futoin.org)\n * Copyright 2018 Andrey Galkin <andrey@futoin.org>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('crypto'),\n  createHash = _require2.createHash,\n  createHmac = _require2.createHmac;\nvar g_digestLenCache = {};\n\n/**\n * Get expected hash length.\n *\n * @func\n * @alias hkdf.hash_length\n * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)\n * @returns {integer} hash digest byte length\n *\n * @note Values are hardcoded with fallback for unknown algorithms.\n */\nvar hash_length = function hash_length(hash) {\n  switch (hash) {\n    case 'sha256':\n      return 32;\n    case 'sha512':\n      return 64;\n    case 'sha224':\n      return 28;\n    case 'sha384':\n      return 48;\n    case 'sha3-256':\n      return 32;\n    case 'sha3-512':\n      return 64;\n    case 'sha3-224':\n      return 28;\n    case 'sha3-384':\n      return 48;\n    case 'blake2s256':\n      return 32;\n    case 'blake2b512':\n      return 64;\n    case 'sha1':\n      return 20;\n    case 'md5':\n      return 16;\n    default:\n      {\n        var len = g_digestLenCache[hash];\n        if (len === undefined) {\n          len = createHash(hash).digest().length;\n          g_digestLenCache[hash] = len;\n        }\n        return len;\n      }\n  }\n};\n\n/**\n * HKDF extract action.\n *\n * @func\n * @alias hkdf.extract\n * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)\n * @param {integer} hash_len - Hash digest length\n * @param {Buffer|string} ikm - Initial Keying Material\n * @param {Buffer|string} salt - Optional salt (recommended)\n * @returns {Buffer} A buffer with pseudorandom key\n *\n * @note Values are hardcoded with fallback for unknown algorithms.\n */\nvar hkdf_extract = function hkdf_extract(hash, hash_len, ikm, salt) {\n  var b_ikm = Buffer.isBuffer(ikm) ? ikm : Buffer.from(ikm);\n  var b_salt = salt && salt.length ? Buffer.from(salt) : Buffer.alloc(hash_len, 0);\n  return createHmac(hash, b_salt).update(b_ikm).digest();\n};\n\n/**\n * HKDF expand action.\n *\n * @func\n * @alias hkdf.expand\n * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)\n * @param {integer} hash_len - Hash digest length\n * @param {Buffer|string} prk - A buffer with pseudorandom key\n * @param {integer} length - length of output keying material in octets\n * @param {Buffer|string} info - Optional context (safe to skip)\n * @returns {Buffer} A buffer with output keying material\n *\n * @note Values are hardcoded with fallback for unknown algorithms.\n */\nvar hkdf_expand = function hkdf_expand(hash, hash_len, prk, length, info) {\n  var b_info = Buffer.isBuffer(info) ? info : Buffer.from(info || '');\n  var info_len = b_info.length;\n  var steps = Math.ceil(length / hash_len);\n  if (steps > 0xFF) {\n    throw new Error(\"OKM length \".concat(length, \" is too long for \").concat(hash, \" hash\"));\n  }\n\n  // use single buffer with unnecessary create/copy/move operations\n  var t = Buffer.alloc(hash_len * steps + info_len + 1);\n  for (var c = 1, start = 0, end = 0; c <= steps; ++c) {\n    // add info\n    b_info.copy(t, end);\n    // add counter\n    t[end + info_len] = c;\n    createHmac(hash, prk)\n    // use view: T(C) = T(C-1) | info | C\n    .update(t.slice(start, end + info_len + 1)).digest()\n    // put back to the same buffer\n    .copy(t, end);\n    start = end; // used for T(C-1) start\n    end += hash_len; // used for T(C-1) end & overall end\n  }\n\n  return t.slice(0, length);\n};\n\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\n *\n * @param {Buffer|string} ikm - Initial Keying Material\n * @param {integer} length - Required byte length of output\n * @param {Buffer|string} salt='' - Optional salt (recommended)\n * @param {Buffer|string} info='' - Optional context (safe to skip)\n * @param {string} hash='SHA-256' - HMAC hash function to use\n * @returns {Buffer} Raw buffer with derived key of @p length bytes\n */\nfunction hkdf(ikm, length) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$salt = _ref.salt,\n    salt = _ref$salt === void 0 ? '' : _ref$salt,\n    _ref$info = _ref.info,\n    info = _ref$info === void 0 ? '' : _ref$info,\n    _ref$hash = _ref.hash,\n    hash = _ref$hash === void 0 ? 'SHA-256' : _ref$hash;\n  hash = hash.toLowerCase().replace('-', '');\n\n  // 0. Hash length\n  var hash_len = hash_length(hash);\n\n  // 1. extract\n  var prk = hkdf_extract(hash, hash_len, ikm, salt);\n\n  // 2. expand\n  return hkdf_expand(hash, hash_len, prk, length, info);\n}\nObject.defineProperties(hkdf, {\n  hash_length: {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: hash_length\n  },\n  extract: {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: hkdf_extract\n  },\n  expand: {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: hkdf_expand\n  }\n});\nmodule.exports = hkdf;","map":null,"metadata":{},"sourceType":"script"}