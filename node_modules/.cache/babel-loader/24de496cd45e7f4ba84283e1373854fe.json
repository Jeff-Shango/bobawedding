{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar defer_to_connect_1 = require(\"defer-to-connect\");\nvar util_1 = require(\"util\");\nvar nodejsMajorVersion = Number(process.versions.node.split('.')[0]);\nvar timer = function timer(request) {\n  if (request.timings) {\n    return request.timings;\n  }\n  var timings = {\n    start: Date.now(),\n    socket: undefined,\n    lookup: undefined,\n    connect: undefined,\n    secureConnect: undefined,\n    upload: undefined,\n    response: undefined,\n    end: undefined,\n    error: undefined,\n    abort: undefined,\n    phases: {\n      wait: undefined,\n      dns: undefined,\n      tcp: undefined,\n      tls: undefined,\n      request: undefined,\n      firstByte: undefined,\n      download: undefined,\n      total: undefined\n    }\n  };\n  request.timings = timings;\n  var handleError = function handleError(origin) {\n    var emit = origin.emit.bind(origin);\n    origin.emit = function (event) {\n      // Catches the `error` event\n      if (event === 'error') {\n        timings.error = Date.now();\n        timings.phases.total = timings.error - timings.start;\n        origin.emit = emit;\n      }\n      // Saves the original behavior\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return emit.apply(void 0, [event].concat(args));\n    };\n  };\n  handleError(request);\n  var onAbort = function onAbort() {\n    timings.abort = Date.now();\n    // Let the `end` response event be responsible for setting the total phase,\n    // unless the Node.js major version is >= 13.\n    if (!timings.response || nodejsMajorVersion >= 13) {\n      timings.phases.total = Date.now() - timings.start;\n    }\n  };\n  request.prependOnceListener('abort', onAbort);\n  var onSocket = function onSocket(socket) {\n    timings.socket = Date.now();\n    timings.phases.wait = timings.socket - timings.start;\n    if (util_1.types.isProxy(socket)) {\n      return;\n    }\n    var lookupListener = function lookupListener() {\n      timings.lookup = Date.now();\n      timings.phases.dns = timings.lookup - timings.socket;\n    };\n    socket.prependOnceListener('lookup', lookupListener);\n    defer_to_connect_1.default(socket, {\n      connect: function connect() {\n        timings.connect = Date.now();\n        if (timings.lookup === undefined) {\n          socket.removeListener('lookup', lookupListener);\n          timings.lookup = timings.connect;\n          timings.phases.dns = timings.lookup - timings.socket;\n        }\n        timings.phases.tcp = timings.connect - timings.lookup;\n        // This callback is called before flushing any data,\n        // so we don't need to set `timings.phases.request` here.\n      },\n\n      secureConnect: function secureConnect() {\n        timings.secureConnect = Date.now();\n        timings.phases.tls = timings.secureConnect - timings.connect;\n      }\n    });\n  };\n  if (request.socket) {\n    onSocket(request.socket);\n  } else {\n    request.prependOnceListener('socket', onSocket);\n  }\n  var onUpload = function onUpload() {\n    var _a;\n    timings.upload = Date.now();\n    timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);\n  };\n  var writableFinished = function writableFinished() {\n    if (typeof request.writableFinished === 'boolean') {\n      return request.writableFinished;\n    }\n    // Node.js doesn't have `request.writableFinished` property\n    return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);\n  };\n  if (writableFinished()) {\n    onUpload();\n  } else {\n    request.prependOnceListener('finish', onUpload);\n  }\n  request.prependOnceListener('response', function (response) {\n    timings.response = Date.now();\n    timings.phases.firstByte = timings.response - timings.upload;\n    response.timings = timings;\n    handleError(response);\n    response.prependOnceListener('end', function () {\n      timings.end = Date.now();\n      timings.phases.download = timings.end - timings.response;\n      timings.phases.total = timings.end - timings.start;\n    });\n    response.prependOnceListener('aborted', onAbort);\n  });\n  return timings;\n};\nexports.default = timer;\n// For CommonJS default export support\nmodule.exports = timer;\nmodule.exports.default = timer;","map":null,"metadata":{},"sourceType":"script"}