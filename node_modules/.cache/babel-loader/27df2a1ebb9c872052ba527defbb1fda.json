{"ast":null,"code":"var _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _objectWithoutProperties = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _require = require('os'),\n  EOL = _require.EOL;\nvar base64url = require('../help/base64url');\nvar isDisjoint = require('../help/is_disjoint');\nvar isObject = require('../help/is_object');\nvar validateCrit = require('../help/validate_crit');\nvar getKey = require('../help/get_key');\nvar _require2 = require('../jwks'),\n  KeyStore = _require2.KeyStore;\nvar errors = require('../errors');\nvar _require3 = require('../jwa'),\n  check = _require3.check,\n  verify = _require3.verify;\nvar JWK = require('../jwk');\nvar _require4 = require('./serializers'),\n  resolveSerialization = _require4.detect;\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid);\nvar SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed']);\n\n/*\n * @public\n */\nvar jwsVerify = function jwsVerify(skipDisjointCheck, serialization, jws, key) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n    _ref$crit = _ref.crit,\n    crit = _ref$crit === void 0 ? [] : _ref$crit,\n    _ref$complete = _ref.complete,\n    complete = _ref$complete === void 0 ? false : _ref$complete,\n    algorithms = _ref.algorithms;\n  key = getKey(key, true);\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(function (s) {\n    return typeof s !== 'string' || !s;\n  }))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n  if (!Array.isArray(crit) || crit.some(function (s) {\n    return typeof s !== 'string' || !s;\n  })) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n  if (!serialization) {\n    serialization = resolveSerialization(jws);\n  }\n  var prot; // protected header\n  var header; // unprotected header\n  var payload;\n  var signature;\n  var alg;\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened';\n    var _jws = jws,\n      _signatures = _jws.signatures,\n      _root = _objectWithoutProperties(_jws, [\"signatures\"]);\n    jws = _objectSpread({}, _root, _signatures[0]);\n  }\n  var decoded;\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    var parsedProt = {};\n    switch (serialization) {\n      case 'compact':\n        // compact serialization format\n        var _jws$split = jws.split('.');\n        var _jws$split2 = _slicedToArray(_jws$split, 3);\n        prot = _jws$split2[0];\n        payload = _jws$split2[1];\n        signature = _jws$split2[2];\n        break;\n      case 'flattened':\n        // flattened serialization format\n        var _jws2 = jws;\n        prot = _jws2.protected;\n        payload = _jws2.payload;\n        signature = _jws2.signature;\n        header = _jws2.header;\n        break;\n      case 'preparsed':\n        {\n          // from the JWT module\n          var _jws3 = jws;\n          decoded = _jws3.decoded;\n          var _jws$token$split = jws.token.split('.');\n          var _jws$token$split2 = _slicedToArray(_jws$token$split, 3);\n          prot = _jws$token$split2[0];\n          payload = _jws$token$split2[1];\n          signature = _jws$token$split2[2];\n          break;\n        }\n    }\n    if (!header) {\n      skipDisjointCheck = true;\n    }\n    if (decoded) {\n      parsedProt = decoded.header;\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot);\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header');\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true;\n    }\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    var combinedHeader = _objectSpread({}, parsedProt, header);\n    validateCrit(parsedProt, header, crit);\n    alg = parsedProt.alg || header && header.alg;\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm');\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n    if (key instanceof KeyStore) {\n      var keystore = key;\n      var keys = keystore.all({\n        kid: combinedHeader.kid,\n        alg: combinedHeader.alg,\n        key_ops: ['verify']\n      });\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n        default:\n          {\n            var _errs = [];\n            var _iterator = _createForOfIteratorHelper(keys),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _key = _step.value;\n                try {\n                  return jwsVerify(true, serialization, jws, _key, {\n                    crit: crit,\n                    complete: complete,\n                    algorithms: algorithms ? _toConsumableArray(algorithms) : undefined\n                  });\n                } catch (err) {\n                  _errs.push(err);\n                  continue;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            var _multi = new errors.JOSEMultiError(_errs);\n            if (_toConsumableArray(_multi).some(function (e) {\n              return e instanceof errors.JWSVerificationFailed;\n            })) {\n              throw new errors.JWSVerificationFailed();\n            }\n            throw _multi;\n          }\n      }\n    }\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object');\n      }\n      key = JWK.asKey(combinedHeader.jwk);\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key');\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(function (c) {\n        return typeof c !== 'string' || !c;\n      })) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings');\n      }\n      key = JWK.asKey(\"-----BEGIN CERTIFICATE-----\".concat(EOL).concat((combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)).concat(EOL, \"-----END CERTIFICATE-----\"), {\n        x5c: combinedHeader.x5c\n      });\n    }\n    check(key, 'verify', alg);\n    var toBeVerified = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.isBuffer(payload) ? payload : Buffer.from(payload)]);\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed();\n    }\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload);\n    } else {\n      payload = base64url.decodeToBuffer(payload);\n    }\n    if (complete) {\n      var result = {\n        payload: payload,\n        key: key\n      };\n      if (prot) result.protected = parsedProt;\n      if (header) result.header = header;\n      return result;\n    }\n    return payload;\n  }\n\n  // general serialization format\n  var _jws4 = jws,\n    signatures = _jws4.signatures,\n    root = _objectWithoutProperties(_jws4, [\"signatures\"]);\n  var errs = [];\n  var _iterator2 = _createForOfIteratorHelper(signatures),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var recipient = _step2.value;\n      try {\n        return jwsVerify(false, 'flattened', _objectSpread({}, root, recipient), key, {\n          crit: crit,\n          complete: complete,\n          algorithms: algorithms ? _toConsumableArray(algorithms) : undefined\n        });\n      } catch (err) {\n        errs.push(err);\n        continue;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var multi = new errors.JOSEMultiError(errs);\n  if (_toConsumableArray(multi).some(function (e) {\n    return e instanceof errors.JWSVerificationFailed;\n  })) {\n    throw new errors.JWSVerificationFailed();\n  } else if (_toConsumableArray(multi).every(function (e) {\n    return e instanceof errors.JWKSNoMatchingKey;\n  })) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n  throw multi;\n};\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n};","map":null,"metadata":{},"sourceType":"script"}