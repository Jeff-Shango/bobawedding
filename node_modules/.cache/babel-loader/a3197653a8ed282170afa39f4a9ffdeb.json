{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _possibleConstructorReturn = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _wrapNativeSuper = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeoutError = void 0;\nvar net = require(\"net\");\nvar unhandle_1 = require(\"./unhandle\");\nvar reentry = Symbol('reentry');\nvar noop = function noop() {};\nvar TimeoutError = /*#__PURE__*/function (_Error) {\n  _inherits(TimeoutError, _Error);\n  function TimeoutError(threshold, event) {\n    var _this;\n    _classCallCheck(this, TimeoutError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TimeoutError).call(this, \"Timeout awaiting '\".concat(event, \"' for \").concat(threshold, \"ms\")));\n    _this.event = event;\n    _this.name = 'TimeoutError';\n    _this.code = 'ETIMEDOUT';\n    return _this;\n  }\n  return TimeoutError;\n}(_wrapNativeSuper(Error));\nexports.TimeoutError = TimeoutError;\nexports.default = function (request, delays, options) {\n  if (reentry in request) {\n    return noop;\n  }\n  request[reentry] = true;\n  var cancelers = [];\n  var _unhandle_1$default = unhandle_1.default(),\n    once = _unhandle_1$default.once,\n    unhandleAll = _unhandle_1$default.unhandleAll;\n  var addTimeout = function addTimeout(delay, callback, event) {\n    var _a;\n    var timeout = setTimeout(callback, delay, delay, event);\n    (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);\n    var cancel = function cancel() {\n      clearTimeout(timeout);\n    };\n    cancelers.push(cancel);\n    return cancel;\n  };\n  var host = options.host,\n    hostname = options.hostname;\n  var timeoutHandler = function timeoutHandler(delay, event) {\n    request.destroy(new TimeoutError(delay, event));\n  };\n  var cancelTimeouts = function cancelTimeouts() {\n    for (var _i = 0, _cancelers = cancelers; _i < _cancelers.length; _i++) {\n      var cancel = _cancelers[_i];\n      cancel();\n    }\n    unhandleAll();\n  };\n  request.once('error', function (error) {\n    cancelTimeouts();\n    // Save original behavior\n    /* istanbul ignore next */\n    if (request.listenerCount('error') === 0) {\n      throw error;\n    }\n  });\n  request.once('close', cancelTimeouts);\n  once(request, 'response', function (response) {\n    once(response, 'end', cancelTimeouts);\n  });\n  if (typeof delays.request !== 'undefined') {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n  if (typeof delays.socket !== 'undefined') {\n    var socketTimeoutHandler = function socketTimeoutHandler() {\n      timeoutHandler(delays.socket, 'socket');\n    };\n    request.setTimeout(delays.socket, socketTimeoutHandler);\n    // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n    cancelers.push(function () {\n      request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n  once(request, 'socket', function (socket) {\n    var _a;\n    var socketPath = request.socketPath;\n    /* istanbul ignore next: hard to test */\n    if (socket.connecting) {\n      var hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);\n      if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n        var cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        once(socket, 'lookup', cancelTimeout);\n      }\n      if (typeof delays.connect !== 'undefined') {\n        var timeConnect = function timeConnect() {\n          return addTimeout(delays.connect, timeoutHandler, 'connect');\n        };\n        if (hasPath) {\n          once(socket, 'connect', timeConnect());\n        } else {\n          once(socket, 'lookup', function (error) {\n            if (error === null) {\n              once(socket, 'connect', timeConnect());\n            }\n          });\n        }\n      }\n      if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n        once(socket, 'connect', function () {\n          var cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          once(socket, 'secureConnect', cancelTimeout);\n        });\n      }\n    }\n    if (typeof delays.send !== 'undefined') {\n      var timeRequest = function timeRequest() {\n        return addTimeout(delays.send, timeoutHandler, 'send');\n      };\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        once(socket, 'connect', function () {\n          once(request, 'upload-complete', timeRequest());\n        });\n      } else {\n        once(request, 'upload-complete', timeRequest());\n      }\n    }\n  });\n  if (typeof delays.response !== 'undefined') {\n    once(request, 'upload-complete', function () {\n      var cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      once(request, 'response', cancelTimeout);\n    });\n  }\n  return cancelTimeouts;\n};","map":null,"metadata":{},"sourceType":"script"}