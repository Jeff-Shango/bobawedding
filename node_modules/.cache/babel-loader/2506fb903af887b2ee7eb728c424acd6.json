{"ast":null,"code":"var _slicedToArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar crypto = require('crypto');\nvar _require = require('jose'),\n  JWKS = _require.JWKS,\n  JWK = _require.JWK,\n  JWS = _require.JWS;\nvar BYTE_LENGTH = 32;\nvar ENCRYPTION_INFO = 'JWE CEK';\nvar SIGNING_INFO = 'JWS Cookie Signing';\nvar DIGEST = 'sha256';\nvar ALG = 'HS256';\nvar CRITICAL_HEADER_PARAMS = ['b64'];\nvar encryption, signing;\n\n/**\n *\n * Derives appropriate sized keys from the end-user provided secret random string/passphrase using\n * HKDF (HMAC-based Extract-and-Expand Key Derivation Function) defined in RFC 8569.\n *\n * @see https://tools.ietf.org/html/rfc5869\n *\n */\n/* istanbul ignore else */\nif (crypto.hkdfSync) {\n  // added in v15.0.0\n  encryption = function encryption(secret) {\n    return Buffer.from(crypto.hkdfSync(DIGEST, secret, Buffer.alloc(0), ENCRYPTION_INFO, BYTE_LENGTH));\n  };\n  signing = function signing(secret) {\n    return Buffer.from(crypto.hkdfSync(DIGEST, secret, Buffer.alloc(0), SIGNING_INFO, BYTE_LENGTH));\n  };\n} else {\n  var hkdf = require('futoin-hkdf');\n  encryption = function encryption(secret) {\n    return hkdf(secret, BYTE_LENGTH, {\n      info: ENCRYPTION_INFO,\n      hash: DIGEST\n    });\n  };\n  signing = function signing(secret) {\n    return hkdf(secret, BYTE_LENGTH, {\n      info: SIGNING_INFO,\n      hash: DIGEST\n    });\n  };\n}\nvar getKeyStore = function getKeyStore(secret, forEncryption) {\n  var current;\n  var secrets = Array.isArray(secret) ? secret : [secret];\n  var keystore = new JWKS.KeyStore();\n  secrets.forEach(function (secretString, i) {\n    var key = JWK.asKey(forEncryption ? encryption(secretString) : signing(secretString));\n    if (i === 0) {\n      current = key;\n    }\n    keystore.add(key);\n  });\n  return [current, keystore];\n};\nvar header = {\n  alg: ALG,\n  b64: false,\n  crit: CRITICAL_HEADER_PARAMS\n};\nvar getPayload = function getPayload(cookie, value) {\n  return Buffer.from(\"\".concat(cookie, \"=\").concat(value));\n};\nvar flattenedJWSFromCookie = function flattenedJWSFromCookie(cookie, value, signature) {\n  return {\n    protected: Buffer.from(JSON.stringify(header)).toString('base64').replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_'),\n    payload: getPayload(cookie, value),\n    signature: signature\n  };\n};\nvar generateSignature = function generateSignature(cookie, value, key) {\n  var payload = getPayload(cookie, value);\n  return JWS.sign.flattened(payload, key, header).signature;\n};\nvar verifySignature = function verifySignature(cookie, value, signature, keystore) {\n  try {\n    return !!JWS.verify(flattenedJWSFromCookie(cookie, value, signature), keystore, {\n      algorithms: [ALG],\n      crit: CRITICAL_HEADER_PARAMS\n    });\n  } catch (err) {\n    return false;\n  }\n};\nvar verifyCookie = function verifyCookie(cookie, value, keystore) {\n  if (!value) {\n    return undefined;\n  }\n  var signature;\n  var _value$split = value.split('.');\n  var _value$split2 = _slicedToArray(_value$split, 2);\n  value = _value$split2[0];\n  signature = _value$split2[1];\n  if (verifySignature(cookie, value, signature, keystore)) {\n    return value;\n  }\n  return undefined;\n};\nvar signCookie = function signCookie(cookie, value, key) {\n  var signature = generateSignature(cookie, value, key);\n  return \"\".concat(value, \".\").concat(signature);\n};\nmodule.exports.signCookie = signCookie;\nmodule.exports.verifyCookie = verifyCookie;\nmodule.exports.getKeyStore = getKeyStore;\nmodule.exports.encryption = encryption;\nmodule.exports.signing = signing;","map":null,"metadata":{},"sourceType":"script"}