{"ast":null,"code":"'use strict';\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nvar _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _inherits = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _setPrototypeOf = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/setPrototypeOf\");\nfunction _wrapRegExp() { _wrapRegExp = function _wrapRegExp(e, r) { return new BabelRegExp(e, void 0, r); }; var e = RegExp.prototype, r = new WeakMap(); function BabelRegExp(e, t, p) { var o = new RegExp(e, t); return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype); } function buildGroups(e, t) { var p = r.get(t); return Object.keys(p).reduce(function (r, t) { var o = p[t]; if (\"number\" == typeof o) r[t] = e[o];else { for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) i++; r[t] = e[o[i]]; } return r; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) { var t = e.exec.call(this, r); if (t) { t.groups = buildGroups(t, this); var p = t.indices; p && (p.groups = buildGroups(p, this)); } return t; }, BabelRegExp.prototype[Symbol.replace] = function (t, p) { if (\"string\" == typeof p) { var o = r.get(this); return e[Symbol.replace].call(this, t, p.replace(/\\$<([^>]+)>/g, function (e, r) { var t = o[r]; return \"$\" + (Array.isArray(t) ? t.join(\"$\") : t); })); } if (\"function\" == typeof p) { var i = this; return e[Symbol.replace].call(this, t, function () { var e = arguments; return \"object\" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e); }); } return e[Symbol.replace].call(this, t, p); }, _wrapRegExp.apply(this, arguments); }\nvar DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';\nvar DATA_URL_DEFAULT_CHARSET = 'us-ascii';\nvar testParameter = function testParameter(name, filters) {\n  return filters.some(function (filter) {\n    return filter instanceof RegExp ? filter.test(name) : filter === name;\n  });\n};\nvar normalizeDataURL = function normalizeDataURL(urlString, _ref) {\n  var stripHash = _ref.stripHash;\n  var match = /*#__PURE__*/_wrapRegExp(/^data:([^,]*?),([^#]*?)(?:#(.*))?$/, {\n    type: 1,\n    data: 2,\n    hash: 3\n  }).exec(urlString);\n  if (!match) {\n    throw new Error(\"Invalid URL: \".concat(urlString));\n  }\n  var _match$groups = match.groups,\n    type = _match$groups.type,\n    data = _match$groups.data,\n    hash = _match$groups.hash;\n  var mediaType = type.split(';');\n  hash = stripHash ? '' : hash;\n  var isBase64 = false;\n  if (mediaType[mediaType.length - 1] === 'base64') {\n    mediaType.pop();\n    isBase64 = true;\n  }\n\n  // Lowercase MIME type\n  var mimeType = (mediaType.shift() || '').toLowerCase();\n  var attributes = mediaType.map(function (attribute) {\n    var _attribute$split$map = attribute.split('=').map(function (string) {\n        return string.trim();\n      }),\n      _attribute$split$map2 = _slicedToArray(_attribute$split$map, 2),\n      key = _attribute$split$map2[0],\n      _attribute$split$map3 = _attribute$split$map2[1],\n      value = _attribute$split$map3 === void 0 ? '' : _attribute$split$map3; // Lowercase `charset`\n    if (key === 'charset') {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return '';\n      }\n    }\n    return \"\".concat(key).concat(value ? \"=\".concat(value) : '');\n  }).filter(Boolean);\n  var normalizedMediaType = _toConsumableArray(attributes);\n  if (isBase64) {\n    normalizedMediaType.push('base64');\n  }\n  if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return \"data:\".concat(normalizedMediaType.join(';'), \",\").concat(isBase64 ? data.trim() : data).concat(hash ? \"#\".concat(hash) : '');\n};\nvar normalizeUrl = function normalizeUrl(urlString, options) {\n  options = _objectSpread({\n    defaultProtocol: 'http:',\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    sortQueryParameters: true\n  }, options);\n  urlString = urlString.trim();\n\n  // Data URL\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (/^view-source:/i.test(urlString)) {\n    throw new Error('`view-source:` is not supported as it is a non-standard protocol');\n  }\n  var hasRelativeProtocol = urlString.startsWith('//');\n  var isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n\n  // Prepend protocol\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  var urlObj = new URL(urlString);\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');\n  }\n  if (options.forceHttp && urlObj.protocol === 'https:') {\n    urlObj.protocol = 'http:';\n  }\n  if (options.forceHttps && urlObj.protocol === 'http:') {\n    urlObj.protocol = 'https:';\n  }\n\n  // Remove auth\n  if (options.stripAuthentication) {\n    urlObj.username = '';\n    urlObj.password = '';\n  }\n\n  // Remove hash\n  if (options.stripHash) {\n    urlObj.hash = '';\n  } else if (options.stripTextFragment) {\n    urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');\n  }\n\n  // Remove duplicate slashes if not preceded by a protocol\n  if (urlObj.pathname) {\n    urlObj.pathname = urlObj.pathname.replace(/(?<!\\b(?:[a-z][a-z\\d+\\-.]{1,50}:))\\/{2,}/g, '/');\n  }\n\n  // Decode URI octets\n  if (urlObj.pathname) {\n    try {\n      urlObj.pathname = decodeURI(urlObj.pathname);\n    } catch (_) {}\n  }\n\n  // Remove directory index\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    var pathComponents = urlObj.pathname.split('/');\n    var lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, pathComponents.length - 1);\n      urlObj.pathname = pathComponents.slice(1).join('/') + '/';\n    }\n  }\n  if (urlObj.hostname) {\n    // Remove trailing dot\n    urlObj.hostname = urlObj.hostname.replace(/\\.$/, '');\n\n    // Remove `www.`\n    if (options.stripWWW && /^www\\.(?!www\\.)(?:[a-z\\-\\d]{1,63})\\.(?:[a-z.\\-\\d]{2,63})$/.test(urlObj.hostname)) {\n      // Each label should be max 63 at length (min: 1).\n      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n      // Each TLD should be up to 63 characters long (min: 2).\n      // It is technically possible to have a single character TLD, but none currently exist.\n      urlObj.hostname = urlObj.hostname.replace(/^www\\./, '');\n    }\n  }\n\n  // Remove query unwanted parameters\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (var _i = 0, _arr = _toConsumableArray(urlObj.searchParams.keys()); _i < _arr.length; _i++) {\n      var key = _arr[_i];\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObj.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.removeQueryParameters === true) {\n    urlObj.search = '';\n  }\n\n  // Sort query parameters\n  if (options.sortQueryParameters) {\n    urlObj.searchParams.sort();\n  }\n  if (options.removeTrailingSlash) {\n    urlObj.pathname = urlObj.pathname.replace(/\\/$/, '');\n  }\n  var oldUrlString = urlString;\n\n  // Take advantage of many of the Node `url` normalizations\n  urlString = urlObj.toString();\n  if (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {\n    urlString = urlString.replace(/\\/$/, '');\n  }\n\n  // Remove ending `/` unless removeSingleSlash is false\n  if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, '');\n  }\n\n  // Restore relative protocol, if applicable\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, '//');\n  }\n\n  // Remove http/https\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, '');\n  }\n  return urlString;\n};\nmodule.exports = normalizeUrl;","map":null,"metadata":{},"sourceType":"script"}