{"ast":null,"code":"'use strict';\n\n// rfc7231 6.1\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _slicedToArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]);\n\n// This implementation does not understand partial responses (206)\nvar understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]);\nvar errorStatusCodes = new Set([500, 502, 503, 504]);\nvar hopByHopHeaders = {\n  date: true,\n  // included, because we add Age update Date\n  connection: true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  te: true,\n  trailer: true,\n  'transfer-encoding': true,\n  upgrade: true\n};\nvar excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\nfunction toNumberOrZero(s) {\n  var n = parseInt(s, 10);\n  return isFinite(n) ? n : 0;\n}\n\n// RFC 5861\nfunction isErrorResponse(response) {\n  // consider undefined response as faulty\n  if (!response) {\n    return true;\n  }\n  return errorStatusCodes.has(response.status);\n}\nfunction parseCacheControl(header) {\n  var cc = {};\n  if (!header) return cc;\n\n  // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n  var parts = header.trim().split(/,/);\n  var _iterator = _createForOfIteratorHelper(parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      var _part$split = part.split(/=/, 2),\n        _part$split2 = _slicedToArray(_part$split, 2),\n        k = _part$split2[0],\n        v = _part$split2[1];\n      cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return cc;\n}\nfunction formatCacheControl(cc) {\n  var parts = [];\n  for (var k in cc) {\n    var v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n  if (!parts.length) {\n    return undefined;\n  }\n  return parts.join(', ');\n}\nmodule.exports = /*#__PURE__*/function () {\n  function CachePolicy(req, res) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      shared = _ref.shared,\n      cacheHeuristic = _ref.cacheHeuristic,\n      immutableMinTimeToLive = _ref.immutableMinTimeToLive,\n      ignoreCargoCult = _ref.ignoreCargoCult,\n      _fromObject = _ref._fromObject;\n    _classCallCheck(this, CachePolicy);\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n      return;\n    }\n    if (!res || !res.headers) {\n      throw Error('Response headers missing');\n    }\n    this._assertRequestHasHeaders(req);\n    this._responseTime = this.now();\n    this._isShared = shared !== false;\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n    this._status = 'status' in res ? res.status : 200;\n    this._resHeaders = res.headers;\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    this._method = 'method' in req ? req.method : 'GET';\n    this._url = req.url;\n    this._host = req.headers.host;\n    this._noAuthorization = !req.headers.authorization;\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n    this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n    if (ignoreCargoCult && 'pre-check' in this._rescc && 'post-check' in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    }\n\n    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n    if (res.headers['cache-control'] == null && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n  _createClass(CachePolicy, [{\n    key: \"now\",\n    value: function now() {\n      return Date.now();\n    }\n  }, {\n    key: \"storable\",\n    value: function storable() {\n      // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n      return !!(!this._reqcc['no-store'] && (\n      // A cache MUST NOT store a response to any request, unless:\n      // The request method is understood by the cache and defined as being cacheable, and\n      'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) &&\n      // the response status code is understood by the cache, and\n      understoodStatuses.has(this._status) &&\n      // the \"no-store\" cache directive does not appear in request or response header fields, and\n      !this._rescc['no-store'] && (\n      // the \"private\" response directive does not appear in the response, if the cache is shared, and\n      !this._isShared || !this._rescc.private) && (\n      // the Authorization header field does not appear in the request, if the cache is shared,\n      !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (\n      // the response either:\n      // contains an Expires header field, or\n      this._resHeaders.expires ||\n      // contains a max-age response directive, or\n      // contains a s-maxage response directive and the cache is shared, or\n      // contains a public response directive.\n      this._rescc['max-age'] || this._isShared && this._rescc['s-maxage'] || this._rescc.public ||\n      // has a status code that is defined as cacheable by default\n      statusCodeCacheableByDefault.has(this._status)));\n    }\n  }, {\n    key: \"_hasExplicitExpiration\",\n    value: function _hasExplicitExpiration() {\n      // 4.2.1 Calculating Freshness Lifetime\n      return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n    }\n  }, {\n    key: \"_assertRequestHasHeaders\",\n    value: function _assertRequestHasHeaders(req) {\n      if (!req || !req.headers) {\n        throw Error('Request headers missing');\n      }\n    }\n  }, {\n    key: \"satisfiesWithoutRevalidation\",\n    value: function satisfiesWithoutRevalidation(req) {\n      this._assertRequestHasHeaders(req);\n\n      // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n      // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n      // unless the stored response is successfully validated (Section 4.3), and\n      var requestCC = parseCacheControl(req.headers['cache-control']);\n      if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n        return false;\n      }\n      if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n        return false;\n      }\n      if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n        return false;\n      }\n\n      // the stored response is either:\n      // fresh, or allowed to be served stale\n      if (this.stale()) {\n        var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n        if (!allowsStale) {\n          return false;\n        }\n      }\n      return this._requestMatches(req, false);\n    }\n  }, {\n    key: \"_requestMatches\",\n    value: function _requestMatches(req, allowHeadMethod) {\n      // The presented effective request URI and that of the stored response match, and\n      return (!this._url || this._url === req.url) && this._host === req.headers.host && (\n      // the request method associated with the stored response allows it to be used for the presented request, and\n      !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) &&\n      // selecting header fields nominated by the stored response (if any) match those presented, and\n      this._varyMatches(req);\n    }\n  }, {\n    key: \"_allowsStoringAuthenticated\",\n    value: function _allowsStoringAuthenticated() {\n      //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n      return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n    }\n  }, {\n    key: \"_varyMatches\",\n    value: function _varyMatches(req) {\n      if (!this._resHeaders.vary) {\n        return true;\n      }\n\n      // A Vary header field-value of \"*\" always fails to match\n      if (this._resHeaders.vary === '*') {\n        return false;\n      }\n      var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n      var _iterator2 = _createForOfIteratorHelper(fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var name = _step2.value;\n          if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"_copyWithoutHopByHopHeaders\",\n    value: function _copyWithoutHopByHopHeaders(inHeaders) {\n      var headers = {};\n      for (var name in inHeaders) {\n        if (hopByHopHeaders[name]) continue;\n        headers[name] = inHeaders[name];\n      }\n      // 9.1.  Connection\n      if (inHeaders.connection) {\n        var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n        var _iterator3 = _createForOfIteratorHelper(tokens),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _name = _step3.value;\n            delete headers[_name];\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      if (headers.warning) {\n        var warnings = headers.warning.split(/,/).filter(function (warning) {\n          return !/^\\s*1[0-9][0-9]/.test(warning);\n        });\n        if (!warnings.length) {\n          delete headers.warning;\n        } else {\n          headers.warning = warnings.join(',').trim();\n        }\n      }\n      return headers;\n    }\n  }, {\n    key: \"responseHeaders\",\n    value: function responseHeaders() {\n      var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n      var age = this.age();\n\n      // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n      // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n        headers.warning = (headers.warning ? \"\".concat(headers.warning, \", \") : '') + '113 - \"rfc7234 5.5.4\"';\n      }\n      headers.age = \"\".concat(Math.round(age));\n      headers.date = new Date(this.now()).toUTCString();\n      return headers;\n    }\n    /**\n     * Value of the Date response header or current time if Date was invalid\n     * @return timestamp\n     */\n  }, {\n    key: \"date\",\n    value: function date() {\n      var serverDate = Date.parse(this._resHeaders.date);\n      if (isFinite(serverDate)) {\n        return serverDate;\n      }\n      return this._responseTime;\n    }\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n  }, {\n    key: \"age\",\n    value: function age() {\n      var age = this._ageValue();\n      var residentTime = (this.now() - this._responseTime) / 1000;\n      return age + residentTime;\n    }\n  }, {\n    key: \"_ageValue\",\n    value: function _ageValue() {\n      return toNumberOrZero(this._resHeaders.age);\n    }\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n  }, {\n    key: \"maxAge\",\n    value: function maxAge() {\n      if (!this.storable() || this._rescc['no-cache']) {\n        return 0;\n      }\n\n      // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n      // so this implementation requires explicit opt-in via public header\n      if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n        return 0;\n      }\n      if (this._resHeaders.vary === '*') {\n        return 0;\n      }\n      if (this._isShared) {\n        if (this._rescc['proxy-revalidate']) {\n          return 0;\n        }\n        // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n        if (this._rescc['s-maxage']) {\n          return toNumberOrZero(this._rescc['s-maxage']);\n        }\n      }\n\n      // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n      if (this._rescc['max-age']) {\n        return toNumberOrZero(this._rescc['max-age']);\n      }\n      var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n      var serverDate = this.date();\n      if (this._resHeaders.expires) {\n        var expires = Date.parse(this._resHeaders.expires);\n        // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n        if (Number.isNaN(expires) || expires < serverDate) {\n          return 0;\n        }\n        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n      }\n      if (this._resHeaders['last-modified']) {\n        var lastModified = Date.parse(this._resHeaders['last-modified']);\n        if (isFinite(lastModified) && serverDate > lastModified) {\n          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);\n        }\n      }\n      return defaultMinTtl;\n    }\n  }, {\n    key: \"timeToLive\",\n    value: function timeToLive() {\n      var age = this.maxAge() - this.age();\n      var staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n      var staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;\n    }\n  }, {\n    key: \"stale\",\n    value: function stale() {\n      return this.maxAge() <= this.age();\n    }\n  }, {\n    key: \"_useStaleIfError\",\n    value: function _useStaleIfError() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n  }, {\n    key: \"useStaleWhileRevalidate\",\n    value: function useStaleWhileRevalidate() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();\n    }\n  }, {\n    key: \"_fromObject\",\n    value: function _fromObject(obj) {\n      if (this._responseTime) throw Error('Reinitialized');\n      if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n      this._responseTime = obj.t;\n      this._isShared = obj.sh;\n      this._cacheHeuristic = obj.ch;\n      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n      this._status = obj.st;\n      this._resHeaders = obj.resh;\n      this._rescc = obj.rescc;\n      this._method = obj.m;\n      this._url = obj.u;\n      this._host = obj.h;\n      this._noAuthorization = obj.a;\n      this._reqHeaders = obj.reqh;\n      this._reqcc = obj.reqcc;\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        v: 1,\n        t: this._responseTime,\n        sh: this._isShared,\n        ch: this._cacheHeuristic,\n        imm: this._immutableMinTtl,\n        st: this._status,\n        resh: this._resHeaders,\n        rescc: this._rescc,\n        m: this._method,\n        u: this._url,\n        h: this._host,\n        a: this._noAuthorization,\n        reqh: this._reqHeaders,\n        reqcc: this._reqcc\n      };\n    }\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n  }, {\n    key: \"revalidationHeaders\",\n    value: function revalidationHeaders(incomingReq) {\n      this._assertRequestHasHeaders(incomingReq);\n      var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n      // This implementation does not understand range requests\n      delete headers['if-range'];\n      if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n        // revalidation allowed via HEAD\n        // not for the same resource, or wasn't allowed to be cached anyway\n        delete headers['if-none-match'];\n        delete headers['if-modified-since'];\n        return headers;\n      }\n\n      /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n      if (this._resHeaders.etag) {\n        headers['if-none-match'] = headers['if-none-match'] ? \"\".concat(headers['if-none-match'], \", \").concat(this._resHeaders.etag) : this._resHeaders.etag;\n      }\n\n      // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n      var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n\n      /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n      Note: This implementation does not understand partial responses (206) */\n      if (forbidsWeakValidators) {\n        delete headers['if-modified-since'];\n        if (headers['if-none-match']) {\n          var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n            return !/^\\s*W\\//.test(etag);\n          });\n          if (!etags.length) {\n            delete headers['if-none-match'];\n          } else {\n            headers['if-none-match'] = etags.join(',').trim();\n          }\n        }\n      } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n        headers['if-modified-since'] = this._resHeaders['last-modified'];\n      }\n      return headers;\n    }\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n  }, {\n    key: \"revalidatedPolicy\",\n    value: function revalidatedPolicy(request, response) {\n      this._assertRequestHasHeaders(request);\n      if (this._useStaleIfError() && isErrorResponse(response)) {\n        // I consider the revalidation request unsuccessful\n        return {\n          modified: false,\n          matches: false,\n          policy: this\n        };\n      }\n      if (!response || !response.headers) {\n        throw Error('Response headers missing');\n      }\n\n      // These aren't going to be supported exactly, since one CachePolicy object\n      // doesn't know about all the other cached objects.\n      var matches = false;\n      if (response.status !== undefined && response.status != 304) {\n        matches = false;\n      } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n        // \"All of the stored responses with the same strong validator are selected.\n        // If none of the stored responses contain the same strong validator,\n        // then the cache MUST NOT use the new response to update any stored responses.\"\n        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n      } else if (this._resHeaders.etag && response.headers.etag) {\n        // \"If the new response contains a weak validator and that validator corresponds\n        // to one of the cache's stored responses,\n        // then the most recent of those matching stored responses is selected for update.\"\n        matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n      } else if (this._resHeaders['last-modified']) {\n        matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n      } else {\n        // If the new response does not include any form of validator (such as in the case where\n        // a client generates an If-Modified-Since request from a source other than the Last-Modified\n        // response header field), and there is only one stored response, and that stored response also\n        // lacks a validator, then that stored response is selected for update.\n        if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n          matches = true;\n        }\n      }\n      if (!matches) {\n        return {\n          policy: new this.constructor(request, response),\n          // Client receiving 304 without body, even if it's invalid/mismatched has no option\n          // but to reuse a cached body. We don't have a good way to tell clients to do\n          // error recovery in such case.\n          modified: response.status != 304,\n          matches: false\n        };\n      }\n\n      // use other header fields provided in the 304 (Not Modified) response to replace all instances\n      // of the corresponding header fields in the stored response.\n      var headers = {};\n      for (var k in this._resHeaders) {\n        headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n      }\n      var newResponse = Object.assign({}, response, {\n        status: this._status,\n        method: this._method,\n        headers: headers\n      });\n      return {\n        policy: new this.constructor(request, newResponse, {\n          shared: this._isShared,\n          cacheHeuristic: this._cacheHeuristic,\n          immutableMinTimeToLive: this._immutableMinTtl\n        }),\n        modified: false,\n        matches: true\n      };\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(obj) {\n      return new this(undefined, undefined, {\n        _fromObject: obj\n      });\n    }\n  }]);\n  return CachePolicy;\n}();","map":null,"metadata":{},"sourceType":"script"}