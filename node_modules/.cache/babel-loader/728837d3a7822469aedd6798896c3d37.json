{"ast":null,"code":";\n(function (exports) {\n  'use strict';\n\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var PLUS = '+'.charCodeAt(0);\n  var SLASH = '/'.charCodeAt(0);\n  var NUMBER = '0'.charCodeAt(0);\n  var LOWER = 'a'.charCodeAt(0);\n  var UPPER = 'A'.charCodeAt(0);\n  var PLUS_URL_SAFE = '-'.charCodeAt(0);\n  var SLASH_URL_SAFE = '_'.charCodeAt(0);\n  function decode(elt) {\n    var code = elt.charCodeAt(0);\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'\n    if (code < NUMBER) return -1; // no match\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;\n    if (code < UPPER + 26) return code - UPPER;\n    if (code < LOWER + 26) return code - LOWER + 26;\n  }\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length;\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0;\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n    var L = 0;\n    function push(v) {\n      arr[L++] = v;\n    }\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n      push((tmp & 0xFF0000) >> 16);\n      push((tmp & 0xFF00) >> 8);\n      push(tmp & 0xFF);\n    }\n    if (placeHolders === 2) {\n      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n      push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n      push(tmp >> 8 & 0xFF);\n      push(tmp & 0xFF);\n    }\n    return arr;\n  }\n  function uint8ToBase64(uint8) {\n    var i;\n    var extraBytes = uint8.length % 3; // if we have 1 byte left, pad 2 bytes\n    var output = '';\n    var temp, length;\n    function encode(num) {\n      return lookup.charAt(num);\n    }\n    function tripletToBase64(num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n    }\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output += tripletToBase64(temp);\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += encode(temp >> 2);\n        output += encode(temp << 4 & 0x3F);\n        output += '==';\n        break;\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n        output += encode(temp >> 10);\n        output += encode(temp >> 4 & 0x3F);\n        output += encode(temp << 2 & 0x3F);\n        output += '=';\n        break;\n      default:\n        break;\n    }\n    return output;\n  }\n  exports.toByteArray = b64ToByteArray;\n  exports.fromByteArray = uint8ToBase64;\n})(typeof exports === 'undefined' ? this.base64js = {} : exports);","map":null,"metadata":{},"sourceType":"script"}