{"ast":null,"code":"var _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar base64url = require('../help/base64url');\nvar isDisjoint = require('../help/is_disjoint');\nvar isObject = require('../help/is_object');\nvar deepClone = require('../help/deep_clone');\nvar _require = require('../errors'),\n  JWSInvalid = _require.JWSInvalid;\nvar _require2 = require('../jwa'),\n  sign = _require2.sign;\nvar getKey = require('../help/get_key');\nvar serializers = require('./serializers');\nvar PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\nvar Sign = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Sign(payload) {\n    _classCallCheck(this, Sign);\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload);\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload);\n      this._binary = true;\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload);\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object');\n    }\n    this._payload = payload;\n    this._recipients = [];\n  }\n\n  /*\n   * @public\n   */\n  _createClass(Sign, [{\n    key: \"recipient\",\n    value: function recipient(key, protectedHeader, unprotectedHeader) {\n      key = getKey(key);\n      if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n        throw new TypeError('protectedHeader argument must be a plain object when provided');\n      }\n      if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n        throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n      }\n      if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n      }\n      this._recipients.push({\n        key: key,\n        protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n        unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n      });\n      return this;\n    }\n    /*\n     * @private\n     */\n  }, {\n    key: PROCESS_RECIPIENT,\n    value: function value(recipient, first) {\n      var key = recipient.key,\n        protectedHeader = recipient.protectedHeader,\n        unprotectedHeader = recipient.unprotectedHeader;\n      if (key.use === 'enc') {\n        throw new TypeError('a key with \"use\":\"enc\" is not usable for signing');\n      }\n      var joseHeader = {\n        protected: protectedHeader || {},\n        unprotected: unprotectedHeader || {}\n      };\n      var alg = joseHeader.protected.alg || joseHeader.unprotected.alg;\n      if (!alg) {\n        alg = key.alg || _toConsumableArray(key.algorithms('sign'))[0];\n        if (recipient.protectedHeader) {\n          joseHeader.protected.alg = recipient.protectedHeader.alg = alg;\n        } else {\n          joseHeader.protected = recipient.protectedHeader = {\n            alg: alg\n          };\n        }\n      }\n      if (!alg) {\n        throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient');\n      }\n      recipient.header = unprotectedHeader;\n      recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : '';\n      if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n        if (this._binary) {\n          this._payload = base64url.decodeToBuffer(this._payload);\n        } else {\n          this._payload = base64url.decode(this._payload);\n        }\n      }\n      var data = Buffer.concat([Buffer.from(recipient.protected || ''), Buffer.from('.'), Buffer.from(this._payload)]);\n      recipient.signature = base64url.encodeBuffer(sign(alg, key, data));\n    }\n    /*\n     * @public\n     */\n  }, {\n    key: \"sign\",\n    value: function sign(serialization) {\n      var _this = this;\n      var serializer = serializers[serialization];\n      if (!serializer) {\n        throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n      }\n      if (!this._recipients.length) {\n        throw new JWSInvalid('missing recipients');\n      }\n      serializer.validate(this, this._recipients);\n      this._recipients.forEach(function (recipient, i) {\n        _this[PROCESS_RECIPIENT](recipient, i === 0);\n      });\n      return serializer(this._payload, this._recipients);\n    }\n  }]);\n  return Sign;\n}();\nmodule.exports = Sign;","map":null,"metadata":{},"sourceType":"script"}