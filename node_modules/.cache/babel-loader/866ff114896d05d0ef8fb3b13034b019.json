{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _objectSpread = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _asyncToGenerator = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jeff/bobawedding/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _require = require('dns'),\n  V4MAPPED = _require.V4MAPPED,\n  ADDRCONFIG = _require.ADDRCONFIG,\n  ALL = _require.ALL,\n  AsyncResolver = _require.promises.Resolver,\n  dnsLookup = _require.lookup;\nvar _require2 = require('util'),\n  promisify = _require2.promisify;\nvar os = require('os');\nvar kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nvar kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nvar kExpires = Symbol('expires');\nvar supportsALL = typeof ALL === 'number';\nvar verifyAgent = function verifyAgent(agent) {\n  if (!(agent && typeof agent.createConnection === 'function')) {\n    throw new Error('Expected an Agent instance as the first argument');\n  }\n};\nvar map4to6 = function map4to6(entries) {\n  var _iterator = _createForOfIteratorHelper(entries),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var entry = _step.value;\n      if (entry.family === 6) {\n        continue;\n      }\n      entry.address = \"::ffff:\".concat(entry.address);\n      entry.family = 6;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar getIfaceInfo = function getIfaceInfo() {\n  var has4 = false;\n  var has6 = false;\n  for (var _i = 0, _Object$values = Object.values(os.networkInterfaces()); _i < _Object$values.length; _i++) {\n    var device = _Object$values[_i];\n    var _iterator2 = _createForOfIteratorHelper(device),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var iface = _step2.value;\n        if (iface.internal) {\n          continue;\n        }\n        if (iface.family === 'IPv6') {\n          has6 = true;\n        } else {\n          has4 = true;\n        }\n        if (has4 && has6) {\n          return {\n            has4: has4,\n            has6: has6\n          };\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return {\n    has4: has4,\n    has6: has6\n  };\n};\nvar isIterable = function isIterable(map) {\n  return Symbol.iterator in map;\n};\nvar ttl = {\n  ttl: true\n};\nvar all = {\n  all: true\n};\nvar CacheableLookup = /*#__PURE__*/function () {\n  function CacheableLookup() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$cache = _ref.cache,\n      cache = _ref$cache === void 0 ? new Map() : _ref$cache,\n      _ref$maxTtl = _ref.maxTtl,\n      maxTtl = _ref$maxTtl === void 0 ? Infinity : _ref$maxTtl,\n      _ref$fallbackDuration = _ref.fallbackDuration,\n      fallbackDuration = _ref$fallbackDuration === void 0 ? 3600 : _ref$fallbackDuration,\n      _ref$errorTtl = _ref.errorTtl,\n      errorTtl = _ref$errorTtl === void 0 ? 0.15 : _ref$errorTtl,\n      _ref$resolver = _ref.resolver,\n      resolver = _ref$resolver === void 0 ? new AsyncResolver() : _ref$resolver,\n      _ref$lookup = _ref.lookup,\n      lookup = _ref$lookup === void 0 ? dnsLookup : _ref$lookup;\n    _classCallCheck(this, CacheableLookup);\n    this.maxTtl = maxTtl;\n    this.errorTtl = errorTtl;\n    this._cache = cache;\n    this._resolver = resolver;\n    this._dnsLookup = promisify(lookup);\n    if (this._resolver instanceof AsyncResolver) {\n      this._resolve4 = this._resolver.resolve4.bind(this._resolver);\n      this._resolve6 = this._resolver.resolve6.bind(this._resolver);\n    } else {\n      this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n      this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n    }\n    this._iface = getIfaceInfo();\n    this._pending = {};\n    this._nextRemovalTime = false;\n    this._hostnamesToFallback = new Set();\n    if (fallbackDuration < 1) {\n      this._fallback = false;\n    } else {\n      this._fallback = true;\n      var interval = setInterval(function () {\n        _this._hostnamesToFallback.clear();\n      }, fallbackDuration * 1000);\n\n      /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n      if (interval.unref) {\n        interval.unref();\n      }\n    }\n    this.lookup = this.lookup.bind(this);\n    this.lookupAsync = this.lookupAsync.bind(this);\n  }\n  _createClass(CacheableLookup, [{\n    key: \"lookup\",\n    value: function lookup(hostname, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else if (typeof options === 'number') {\n        options = {\n          family: options\n        };\n      }\n      if (!callback) {\n        throw new Error('Callback must be a function.');\n      }\n\n      // eslint-disable-next-line promise/prefer-await-to-then\n      this.lookupAsync(hostname, options).then(function (result) {\n        if (options.all) {\n          callback(null, result);\n        } else {\n          callback(null, result.address, result.family, result.expires, result.ttl);\n        }\n      }, callback);\n    }\n  }, {\n    key: \"lookupAsync\",\n    value: function () {\n      var _lookupAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hostname) {\n        var options,\n          cached,\n          filtered,\n          _iface,\n          error,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              if (typeof options === 'number') {\n                options = {\n                  family: options\n                };\n              }\n              _context.next = 4;\n              return this.query(hostname);\n            case 4:\n              cached = _context.sent;\n              if (options.family === 6) {\n                filtered = cached.filter(function (entry) {\n                  return entry.family === 6;\n                });\n                if (options.hints & V4MAPPED) {\n                  if (supportsALL && options.hints & ALL || filtered.length === 0) {\n                    map4to6(cached);\n                  } else {\n                    cached = filtered;\n                  }\n                } else {\n                  cached = filtered;\n                }\n              } else if (options.family === 4) {\n                cached = cached.filter(function (entry) {\n                  return entry.family === 4;\n                });\n              }\n              if (options.hints & ADDRCONFIG) {\n                _iface = this._iface;\n                cached = cached.filter(function (entry) {\n                  return entry.family === 6 ? _iface.has6 : _iface.has4;\n                });\n              }\n              if (!(cached.length === 0)) {\n                _context.next = 12;\n                break;\n              }\n              error = new Error(\"cacheableLookup ENOTFOUND \".concat(hostname));\n              error.code = 'ENOTFOUND';\n              error.hostname = hostname;\n              throw error;\n            case 12:\n              if (!options.all) {\n                _context.next = 14;\n                break;\n              }\n              return _context.abrupt(\"return\", cached);\n            case 14:\n              return _context.abrupt(\"return\", cached[0]);\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function lookupAsync(_x) {\n        return _lookupAsync.apply(this, arguments);\n      }\n      return lookupAsync;\n    }()\n  }, {\n    key: \"query\",\n    value: function () {\n      var _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hostname) {\n        var cached, pending, newPromise;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this._cache.get(hostname);\n            case 2:\n              cached = _context2.sent;\n              if (cached) {\n                _context2.next = 20;\n                break;\n              }\n              pending = this._pending[hostname];\n              if (!pending) {\n                _context2.next = 11;\n                break;\n              }\n              _context2.next = 8;\n              return pending;\n            case 8:\n              cached = _context2.sent;\n              _context2.next = 20;\n              break;\n            case 11:\n              newPromise = this.queryAndCache(hostname);\n              this._pending[hostname] = newPromise;\n              _context2.prev = 13;\n              _context2.next = 16;\n              return newPromise;\n            case 16:\n              cached = _context2.sent;\n            case 17:\n              _context2.prev = 17;\n              delete this._pending[hostname];\n              return _context2.finish(17);\n            case 20:\n              cached = cached.map(function (entry) {\n                return _objectSpread({}, entry);\n              });\n              return _context2.abrupt(\"return\", cached);\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[13,, 17, 20]]);\n      }));\n      function query(_x2) {\n        return _query.apply(this, arguments);\n      }\n      return query;\n    }()\n  }, {\n    key: \"_resolve\",\n    value: function () {\n      var _resolve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(hostname) {\n        var wrap, _yield$Promise$all, _yield$Promise$all2, A, AAAA, aTtl, aaaaTtl, cacheTtl, now, _iterator3, _step3, entry, _iterator4, _step4, _entry;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              wrap = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(promise) {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.prev = 0;\n                        _context3.next = 3;\n                        return promise;\n                      case 3:\n                        return _context3.abrupt(\"return\", _context3.sent);\n                      case 6:\n                        _context3.prev = 6;\n                        _context3.t0 = _context3[\"catch\"](0);\n                        if (!(_context3.t0.code === 'ENODATA' || _context3.t0.code === 'ENOTFOUND')) {\n                          _context3.next = 10;\n                          break;\n                        }\n                        return _context3.abrupt(\"return\", []);\n                      case 10:\n                        throw _context3.t0;\n                      case 11:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[0, 6]]);\n                }));\n                return function wrap(_x4) {\n                  return _ref2.apply(this, arguments);\n                };\n              }(); // ANY is unsafe as it doesn't trigger new queries in the underlying server.\n              _context4.next = 3;\n              return Promise.all([this._resolve4(hostname, ttl), this._resolve6(hostname, ttl)].map(function (promise) {\n                return wrap(promise);\n              }));\n            case 3:\n              _yield$Promise$all = _context4.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              A = _yield$Promise$all2[0];\n              AAAA = _yield$Promise$all2[1];\n              aTtl = 0;\n              aaaaTtl = 0;\n              cacheTtl = 0;\n              now = Date.now();\n              _iterator3 = _createForOfIteratorHelper(A);\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  entry = _step3.value;\n                  entry.family = 4;\n                  entry.expires = now + entry.ttl * 1000;\n                  aTtl = Math.max(aTtl, entry.ttl);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              _iterator4 = _createForOfIteratorHelper(AAAA);\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  _entry = _step4.value;\n                  _entry.family = 6;\n                  _entry.expires = now + _entry.ttl * 1000;\n                  aaaaTtl = Math.max(aaaaTtl, _entry.ttl);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n              if (A.length > 0) {\n                if (AAAA.length > 0) {\n                  cacheTtl = Math.min(aTtl, aaaaTtl);\n                } else {\n                  cacheTtl = aTtl;\n                }\n              } else {\n                cacheTtl = aaaaTtl;\n              }\n              return _context4.abrupt(\"return\", {\n                entries: [].concat(_toConsumableArray(A), _toConsumableArray(AAAA)),\n                cacheTtl: cacheTtl\n              });\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _resolve(_x3) {\n        return _resolve2.apply(this, arguments);\n      }\n      return _resolve;\n    }()\n  }, {\n    key: \"_lookup\",\n    value: function () {\n      var _lookup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(hostname) {\n        var entries;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n              _context5.next = 3;\n              return this._dnsLookup(hostname, {\n                all: true\n              });\n            case 3:\n              entries = _context5.sent;\n              return _context5.abrupt(\"return\", {\n                entries: entries,\n                cacheTtl: 0\n              });\n            case 7:\n              _context5.prev = 7;\n              _context5.t0 = _context5[\"catch\"](0);\n              return _context5.abrupt(\"return\", {\n                entries: [],\n                cacheTtl: 0\n              });\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n      function _lookup(_x5) {\n        return _lookup2.apply(this, arguments);\n      }\n      return _lookup;\n    }()\n  }, {\n    key: \"_set\",\n    value: function () {\n      var _set2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(hostname, data, cacheTtl) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(this.maxTtl > 0 && cacheTtl > 0)) {\n                _context7.next = 12;\n                break;\n              }\n              cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n              data[kExpires] = Date.now() + cacheTtl;\n              _context7.prev = 3;\n              _context7.next = 6;\n              return this._cache.set(hostname, data, cacheTtl);\n            case 6:\n              _context7.next = 11;\n              break;\n            case 8:\n              _context7.prev = 8;\n              _context7.t0 = _context7[\"catch\"](3);\n              this.lookupAsync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                var cacheError;\n                return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                  while (1) switch (_context6.prev = _context6.next) {\n                    case 0:\n                      cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n                      cacheError.cause = _context7.t0;\n                      throw cacheError;\n                    case 3:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }, _callee6);\n              }));\n            case 11:\n              if (isIterable(this._cache)) {\n                this._tick(cacheTtl);\n              }\n            case 12:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[3, 8]]);\n      }));\n      function _set(_x6, _x7, _x8) {\n        return _set2.apply(this, arguments);\n      }\n      return _set;\n    }()\n  }, {\n    key: \"queryAndCache\",\n    value: function () {\n      var _queryAndCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(hostname) {\n        var query, cacheTtl;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!this._hostnamesToFallback.has(hostname)) {\n                _context8.next = 2;\n                break;\n              }\n              return _context8.abrupt(\"return\", this._dnsLookup(hostname, all));\n            case 2:\n              _context8.next = 4;\n              return this._resolve(hostname);\n            case 4:\n              query = _context8.sent;\n              if (!(query.entries.length === 0 && this._fallback)) {\n                _context8.next = 10;\n                break;\n              }\n              _context8.next = 8;\n              return this._lookup(hostname);\n            case 8:\n              query = _context8.sent;\n              if (query.entries.length !== 0) {\n                // Use `dns.lookup(...)` for that particular hostname\n                this._hostnamesToFallback.add(hostname);\n              }\n            case 10:\n              cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n              _context8.next = 13;\n              return this._set(hostname, query.entries, cacheTtl);\n            case 13:\n              return _context8.abrupt(\"return\", query.entries);\n            case 14:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function queryAndCache(_x9) {\n        return _queryAndCache.apply(this, arguments);\n      }\n      return queryAndCache;\n    }()\n  }, {\n    key: \"_tick\",\n    value: function _tick(ms) {\n      var _this2 = this;\n      var nextRemovalTime = this._nextRemovalTime;\n      if (!nextRemovalTime || ms < nextRemovalTime) {\n        clearTimeout(this._removalTimeout);\n        this._nextRemovalTime = ms;\n        this._removalTimeout = setTimeout(function () {\n          _this2._nextRemovalTime = false;\n          var nextExpiry = Infinity;\n          var now = Date.now();\n          var _iterator5 = _createForOfIteratorHelper(_this2._cache),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                hostname = _step5$value[0],\n                entries = _step5$value[1];\n              var expires = entries[kExpires];\n              if (now >= expires) {\n                _this2._cache.delete(hostname);\n              } else if (expires < nextExpiry) {\n                nextExpiry = expires;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          if (nextExpiry !== Infinity) {\n            _this2._tick(nextExpiry - now);\n          }\n        }, ms);\n\n        /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n        if (this._removalTimeout.unref) {\n          this._removalTimeout.unref();\n        }\n      }\n    }\n  }, {\n    key: \"install\",\n    value: function install(agent) {\n      var _this3 = this;\n      verifyAgent(agent);\n      if (kCacheableLookupCreateConnection in agent) {\n        throw new Error('CacheableLookup has been already installed');\n      }\n      agent[kCacheableLookupCreateConnection] = agent.createConnection;\n      agent[kCacheableLookupInstance] = this;\n      agent.createConnection = function (options, callback) {\n        if (!('lookup' in options)) {\n          options.lookup = _this3.lookup;\n        }\n        return agent[kCacheableLookupCreateConnection](options, callback);\n      };\n    }\n  }, {\n    key: \"uninstall\",\n    value: function uninstall(agent) {\n      verifyAgent(agent);\n      if (agent[kCacheableLookupCreateConnection]) {\n        if (agent[kCacheableLookupInstance] !== this) {\n          throw new Error('The agent is not owned by this CacheableLookup instance');\n        }\n        agent.createConnection = agent[kCacheableLookupCreateConnection];\n        delete agent[kCacheableLookupCreateConnection];\n        delete agent[kCacheableLookupInstance];\n      }\n    }\n  }, {\n    key: \"updateInterfaceInfo\",\n    value: function updateInterfaceInfo() {\n      var _iface = this._iface;\n      this._iface = getIfaceInfo();\n      if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {\n        this._cache.clear();\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(hostname) {\n      if (hostname) {\n        this._cache.delete(hostname);\n        return;\n      }\n      this._cache.clear();\n    }\n  }, {\n    key: \"servers\",\n    set: function set(servers) {\n      this.clear();\n      this._resolver.setServers(servers);\n    },\n    get: function get() {\n      return this._resolver.getServers();\n    }\n  }]);\n  return CacheableLookup;\n}();\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;","map":null,"metadata":{},"sourceType":"script"}